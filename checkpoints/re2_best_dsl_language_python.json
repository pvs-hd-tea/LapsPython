{
    "grammar": {
        "primitives": {
            "_rdot": {
                "name": "rdot",
                "handle": "_rdot",
                "source": ".",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_rempty": {
                "name": "rempty",
                "handle": "_rempty",
                "source": "",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_a": {
                "name": "a",
                "handle": "_a",
                "source": "a",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_b": {
                "name": "b",
                "handle": "_b",
                "source": "b",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_c": {
                "name": "c",
                "handle": "_c",
                "source": "c",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_d": {
                "name": "d",
                "handle": "_d",
                "source": "d",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_e": {
                "name": "e",
                "handle": "_e",
                "source": "e",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_f": {
                "name": "f",
                "handle": "_f",
                "source": "f",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_g": {
                "name": "g",
                "handle": "_g",
                "source": "g",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_h": {
                "name": "h",
                "handle": "_h",
                "source": "h",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_i": {
                "name": "i",
                "handle": "_i",
                "source": "i",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_j": {
                "name": "j",
                "handle": "_j",
                "source": "j",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_k": {
                "name": "k",
                "handle": "_k",
                "source": "k",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_l": {
                "name": "l",
                "handle": "_l",
                "source": "l",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_m": {
                "name": "m",
                "handle": "_m",
                "source": "m",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_n": {
                "name": "n",
                "handle": "_n",
                "source": "n",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_o": {
                "name": "o",
                "handle": "_o",
                "source": "o",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_p": {
                "name": "p",
                "handle": "_p",
                "source": "p",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_q": {
                "name": "q",
                "handle": "_q",
                "source": "q",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_r": {
                "name": "r",
                "handle": "_r",
                "source": "r",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_s": {
                "name": "s",
                "handle": "_s",
                "source": "s",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_t": {
                "name": "t",
                "handle": "_t",
                "source": "t",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_u": {
                "name": "u",
                "handle": "_u",
                "source": "u",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_v": {
                "name": "v",
                "handle": "_v",
                "source": "v",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_w": {
                "name": "w",
                "handle": "_w",
                "source": "w",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_x": {
                "name": "x",
                "handle": "_x",
                "source": "x",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_y": {
                "name": "y",
                "handle": "_y",
                "source": "y",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_z": {
                "name": "z",
                "handle": "_z",
                "source": "z",
                "args": [],
                "imports": [],
                "dependencies": []
            },
            "_rnot": {
                "name": "rnot",
                "handle": "_rnot",
                "source": "return f\"[^{s}]\"",
                "args": [
                    "s"
                ],
                "imports": [
                    "re"
                ],
                "dependencies": []
            },
            "_ror": {
                "name": "ror",
                "handle": "_ror",
                "source": "return f\"(({s1})|({s2}))\"",
                "args": [
                    "s1",
                    "s2"
                ],
                "imports": [
                    "re"
                ],
                "dependencies": []
            },
            "_rconcat": {
                "name": "rconcat",
                "handle": "_rconcat",
                "source": "return s1 + s2",
                "args": [
                    "s1",
                    "s2"
                ],
                "imports": [
                    "re"
                ],
                "dependencies": []
            },
            "_rmatch": {
                "name": "rmatch",
                "handle": "_rmatch",
                "source": "return __ismatch(s1, s2)",
                "args": [
                    "s1",
                    "s2"
                ],
                "imports": [
                    "re"
                ],
                "dependencies": [
                    "def __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n"
                ]
            },
            "_rsplit": {
                "name": "rsplit",
                "handle": "_rsplit",
                "source": "return __regex_split(s1, s2)",
                "args": [
                    "s1",
                    "s2"
                ],
                "imports": [
                    "re"
                ],
                "dependencies": [
                    "def __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n"
                ]
            },
            "_rflatten": {
                "name": "rflatten",
                "handle": "_rflatten",
                "source": "return \"\".join(l)",
                "args": [
                    "l"
                ],
                "imports": [
                    "re"
                ],
                "dependencies": []
            },
            "_rtail": {
                "name": "rtail",
                "handle": "_rtail",
                "source": "return l[-1]",
                "args": [
                    "l"
                ],
                "imports": [
                    "re"
                ],
                "dependencies": []
            },
            "_rappend": {
                "name": "rappend",
                "handle": "_rappend",
                "source": "return l + [x]",
                "args": [
                    "x",
                    "l"
                ],
                "imports": [
                    "re"
                ],
                "dependencies": []
            },
            "_rrevcdr": {
                "name": "rrevcdr",
                "handle": "_rrevcdr",
                "source": "return l[:-1]",
                "args": [
                    "l"
                ],
                "imports": [
                    "re"
                ],
                "dependencies": []
            },
            "if": {
                "name": "if",
                "handle": "if",
                "source": "return t if c else f",
                "args": [
                    "c",
                    "t",
                    "f"
                ],
                "imports": [],
                "dependencies": []
            },
            "cons": {
                "name": "cons",
                "handle": "cons",
                "source": "return [x] + y",
                "args": [
                    "x",
                    "y"
                ],
                "imports": [],
                "dependencies": []
            },
            "car": {
                "name": "car",
                "handle": "car",
                "source": "return x[0]",
                "args": [
                    "x"
                ],
                "imports": [],
                "dependencies": []
            },
            "cdr": {
                "name": "cdr",
                "handle": "cdr",
                "source": "return x[1:]",
                "args": [
                    "x"
                ],
                "imports": [],
                "dependencies": []
            },
            "map": {
                "name": "map",
                "handle": "map",
                "source": "return list(map(f, l))",
                "args": [
                    "f",
                    "l"
                ],
                "imports": [],
                "dependencies": []
            }
        },
        "invented": {
            "#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2))))))": {
                "name": "f0",
                "handle": "#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2))))))",
                "source": "rconcat_1 = arg2 + arg3\nreturn f8(f8_0, arg3, lambda lx: lx + lx)",
                "args": [
                    "arg1",
                    "arg2",
                    "arg3"
                ],
                "imports": [],
                "dependencies": [
                    "def f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n",
                    "def __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n"
                ]
            },
            "#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1))))": {
                "name": "f1",
                "handle": "#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1))))",
                "source": "rrevcdr_1 = arg1[:-1]\ncar_1 = rrevcdr_1[0]\nrmatch_1 = __ismatch(car_1, arg2)\nreturn arg1 if rmatch_1 else arg2",
                "args": [
                    "arg1",
                    "arg2",
                    "arg3",
                    "arg4"
                ],
                "imports": [],
                "dependencies": [
                    "def __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n"
                ]
            },
            "#(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend (if (_rmatch (_rtail $0) _e) _e $1) (_rrevcdr $0)))))": {
                "name": "f2",
                "handle": "#(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend (if (_rmatch (_rtail $0) _e) _e $1) (_rrevcdr $0)))))",
                "source": "rrevcdr_1 = arg1[:-1]\nrtail_1 = arg1[-1]\nrmatch_1 = __ismatch(rtail_1, 'e')\nif_1 = 'e' if rmatch_1 else arg2\nrappend_1 = rrevcdr_1 + [if_1]\nreturn f6(f6_0, lambda lx: rrevcdr_1 + [if_1])",
                "args": [
                    "arg1",
                    "arg2"
                ],
                "imports": [],
                "dependencies": [
                    "def __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n",
                    "def __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n",
                    "def f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n"
                ]
            },
            "#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0)))))))": {
                "name": "f3",
                "handle": "#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0)))))))",
                "source": "rrevcdr_1 = arg1[:-1]\nrappend_1 = rrevcdr_1 + [arg2]\nrappend_2 = rappend_1 + [arg3]\nreturn f6(f6_0, lambda lx: rappend_1 + [lx])",
                "args": [
                    "arg1",
                    "arg2",
                    "arg3"
                ],
                "imports": [],
                "dependencies": [
                    "def __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n",
                    "def f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n"
                ]
            },
            "#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0))))))": {
                "name": "f4",
                "handle": "#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0))))))",
                "source": "rconcat_1 = arg2 + arg1\nreturn f7(f7_0, arg3, arg4, rconcat_1)",
                "args": [
                    "arg1",
                    "arg2",
                    "arg3",
                    "arg4"
                ],
                "imports": [],
                "dependencies": [
                    "def f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n",
                    "def __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n",
                    "def f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n",
                    "def __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n"
                ]
            },
            "#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2))))))": {
                "name": "f5",
                "handle": "#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2))))))",
                "source": "cdr_1 = arg3[1:]\ncons_1 = [arg2] + cdr_1\nreturn [arg1] + cons_1",
                "args": [
                    "arg1",
                    "arg2",
                    "arg3"
                ],
                "imports": [],
                "dependencies": []
            },
            "#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0)))))": {
                "name": "f6",
                "handle": "#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0)))))",
                "source": "rsplit_1 = __regex_split('.', arg1)\nreturn \"\".join(['arg2', 'rsplit_1'])",
                "args": [
                    "arg1",
                    "arg2"
                ],
                "imports": [],
                "dependencies": [
                    "def __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n"
                ]
            },
            "#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0))))))": {
                "name": "f7",
                "handle": "#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0))))))",
                "source": "rmatch_1 = __ismatch(arg4, arg1)\nif_1 = arg2 if rmatch_1 else arg1\nreturn f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)",
                "args": [
                    "arg1",
                    "arg2",
                    "arg3"
                ],
                "imports": [],
                "dependencies": [
                    "def f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n",
                    "def __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n",
                    "def __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n"
                ]
            },
            "#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1)))))": {
                "name": "f8",
                "handle": "#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1)))))",
                "source": "rsplit_1 = __regex_split('.', arg2)\nmap_1 = list(map(arg1, rsplit_1))\nreturn \"\".join(map_1)",
                "args": [
                    "arg1",
                    "arg2"
                ],
                "imports": [],
                "dependencies": [
                    "def __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n"
                ]
            }
        }
    },
    "result": [
        {
            "annotation": "if the word ends with any letter add w after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend _w $0)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_0_if_the_word_ends_with_any_letter_add_w_after_that(arg1):\n    rappend_1 = arg1 + ['w']\n    return f6(f6_0, lambda lx: lx + ['w'], arg1)"
        },
        {
            "annotation": "if there is d replace that with y",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _d $0 _y))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_3_if_there_is_d_replace_that_with_y(arg1):\n    return f7(f7_0, 'd', arg1, 'y')"
        },
        {
            "annotation": "if there is b add k before that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _b _k _b))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_4_if_there_is_b_add_k_before_that(arg1):\n    return f4(f4_0, arg1, 'b', 'k', 'b')"
        },
        {
            "annotation": "if the word starts with any letter any letter add f after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons (car $0) (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) (cdr $0) _f (car (_rrevcdr (cdr $0)))))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_6_if_the_word_starts_with_any_letter_any_letter_add_f_after_that(arg1):\n    cdr_1 = arg1[1:]\n    rrevcdr_1 = cdr_1[:-1]\n    car_1 = rrevcdr_1[0]\n    cdr_2 = arg1[1:]\n    f5_1 = f5(f5_0, cdr_2, 'f', car_1)\n    car_2 = arg1[0]\n    cons_1 = [car_2] + f5_1\n    return f6(f6_0, lambda lx: [car_2] + f5_1, arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with r u",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _u _r)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_11_if_the_word_starts_with_any_letter_replace_that_with_r_u(arg1):\n    f5_1 = f5(f5_0, arg1, 'u', 'r')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'u', 'r'), arg1)"
        },
        {
            "annotation": "if there is t replace that with a x",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _t _a _x))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_14_if_there_is_t_replace_that_with_a_x(arg1):\n    return f4(f4_0, arg1, 't', 'a', 'x')"
        },
        {
            "annotation": "if the word starts with any letter any letter replace that with l n",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) (cdr $0) _n _l)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_17_if_the_word_starts_with_any_letter_any_letter_replace_that_with_l_n(arg1):\n    cdr_1 = arg1[1:]\n    f5_1 = f5(f5_0, cdr_1, 'n', 'l')\n    return f6(f6_0, lambda lx: f5(f5_0, cdr_1, 'n', 'l'), arg1)"
        },
        {
            "annotation": "if the word ends with any letter consonant replace that with v",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (if (_rmatch (_rtail $0) _e) $0 (_rappend _v (_rrevcdr (_rrevcdr $0))))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_19_if_the_word_ends_with_any_letter_consonant_replace_that_with_v(arg1):\n    rrevcdr_1 = arg1[:-1]\n    rrevcdr_2 = rrevcdr_1[:-1]\n    rappend_1 = rrevcdr_2 + ['v']\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 'e')\n    if_1 = arg1 if rmatch_1 else rappend_1\n    return f6(f6_0, lambda lx: lx if rmatch_1 else rappend_1, arg1)"
        },
        {
            "annotation": "if there is e add e before that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _e _e _e))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_20_if_there_is_e_add_e_before_that(arg1):\n    return f4(f4_0, arg1, 'e', 'e', 'e')"
        },
        {
            "annotation": "if the word starts with any letter replace that with n a",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _a _n)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_21_if_the_word_starts_with_any_letter_replace_that_with_n_a(arg1):\n    f5_1 = f5(f5_0, arg1, 'a', 'n')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'a', 'n'), arg1)"
        },
        {
            "annotation": "if there is any letter replace that with k",
            "best_program": "(lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $0 (lambda _k)))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_23_if_there_is_any_letter_replace_that_with_k(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    map_1 = list(map(lambda lx: 'k', rsplit_1))\n    return \"\".join(map_1)",
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef re2_train_23_if_there_is_any_letter_replace_that_with_k(arg1):\n    return f8(f8_0, arg1, lambda lx: 'k')"
        },
        {
            "annotation": "if the word starts with any letter any letter add b after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons (car (_rrevcdr $0)) (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) (cdr $0) _b (car (_rrevcdr (cdr $0)))))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_24_if_the_word_starts_with_any_letter_any_letter_add_b_after_that(arg1):\n    cdr_1 = arg1[1:]\n    rrevcdr_1 = cdr_1[:-1]\n    car_1 = rrevcdr_1[0]\n    cdr_2 = arg1[1:]\n    f5_1 = f5(f5_0, cdr_2, 'b', car_1)\n    rrevcdr_2 = arg1[:-1]\n    car_2 = rrevcdr_2[0]\n    cons_1 = [car_2] + f5_1\n    return f6(f6_0, lambda lx: [car_2] + f5_1, arg1)"
        },
        {
            "annotation": "if the word ends with any letter replace that with r",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _r _rempty $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_26_if_the_word_ends_with_any_letter_replace_that_with_r(arg1):\n    return f3(f3_0, 'r', '', arg1)"
        },
        {
            "annotation": "if the word ends with any letter any letter replace that with o u",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _u _o (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rrevcdr $0)) $0)))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_29_if_the_word_ends_with_any_letter_any_letter_replace_that_with_o_u(arg1):\n    rrevcdr_1 = arg1[:-1]\n    f6_1 = f6(f6_0, lambda lx: lx[:-1], arg1)\n    return f3(f3_0, 'u', 'o', f6_1)"
        },
        {
            "annotation": "if there is p replace that with f w",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _p _f _w))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_32_if_there_is_p_replace_that_with_f_w(arg1):\n    return f4(f4_0, arg1, 'p', 'f', 'w')"
        },
        {
            "annotation": "if the word ends with any letter add d after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend _d $0)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_34_if_the_word_ends_with_any_letter_add_d_after_that(arg1):\n    rappend_1 = arg1 + ['d']\n    return f6(f6_0, lambda lx: lx + ['d'], arg1)"
        },
        {
            "annotation": "if there is any letter replace that with q j",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _j _q))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_35_if_there_is_any_letter_replace_that_with_q_j(arg1):\n    return f0(f0_0, arg1, 'j', 'q')"
        },
        {
            "annotation": "if there is g add q before that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _g _q _g))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_37_if_there_is_g_add_q_before_that(arg1):\n    return f4(f4_0, arg1, 'g', 'q', 'g')"
        },
        {
            "annotation": "if there is c add d before that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _c _d _c))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_39_if_there_is_c_add_d_before_that(arg1):\n    return f4(f4_0, arg1, 'c', 'd', 'c')"
        },
        {
            "annotation": "if there is any letter add v after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $0 (lambda (_rconcat $0 _v))))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef re2_train_41_if_there_is_any_letter_add_v_after_that(arg1):\n    rconcat_1 = arg1 + 'v'\n    return f8(f8_0, arg1, lambda lx: lx + 'v')"
        },
        {
            "annotation": "if there is u replace that with l q",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _u _l _q))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_47_if_there_is_u_replace_that_with_l_q(arg1):\n    return f4(f4_0, arg1, 'u', 'l', 'q')"
        },
        {
            "annotation": "if the word starts with consonant e add l before that",
            "best_program": "(lambda (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _e (cdr (_rsplit _rempty $0)) (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _l $0)) $0) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f1(arg1, arg2, arg3, arg4):\n    rrevcdr_1 = arg1[:-1]\n    car_1 = rrevcdr_1[0]\n    rmatch_1 = __ismatch(car_1, arg2)\n    return arg1 if rmatch_1 else arg2\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_49_if_the_word_starts_with_consonant_e_add_l_before_that(arg1):\n    cons_1 = ['l'] + arg1\n    f6_1 = f6(f6_0, lambda lx: ['l'] + lx, arg1)\n    rsplit_1 = __regex_split('', arg1)\n    cdr_1 = rsplit_1[1:]\n    return f1(f1_0, 'e', cdr_1, f6_1, arg1)"
        },
        {
            "annotation": "if the word ends with any letter replace that with f",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend _f (_rrevcdr $0))) $0))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_52_if_the_word_ends_with_any_letter_replace_that_with_f(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    rrevcdr_1 = rsplit_1[:-1]\n    rappend_1 = rrevcdr_1 + ['f']\n    return \"\".join(rappend_1)",
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_52_if_the_word_ends_with_any_letter_replace_that_with_f(arg1):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + ['f']\n    return f6(f6_0, lambda lx: rrevcdr_1 + ['f'], arg1)"
        },
        {
            "annotation": "if the word ends with any letter replace that with t m",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _m _t $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_53_if_the_word_ends_with_any_letter_replace_that_with_t_m(arg1):\n    return f3(f3_0, 'm', 't', arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with e e",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _e _e)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_60_if_the_word_starts_with_any_letter_replace_that_with_e_e(arg1):\n    f5_1 = f5(f5_0, arg1, 'e', 'e')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'e', 'e'), arg1)"
        },
        {
            "annotation": "if the word starts with any letter any letter add j before that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _j $0)) $0))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_66_if_the_word_starts_with_any_letter_any_letter_add_j_before_that(arg1):\n    rsplit_1 = __regex_split('a', arg1)\n    cons_1 = ['j'] + rsplit_1\n    return \"\".join(cons_1)",
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_66_if_the_word_starts_with_any_letter_any_letter_add_j_before_that(arg1):\n    cons_1 = ['j'] + arg1\n    return f6(f6_0, lambda lx: ['j'] + lx, arg1)"
        },
        {
            "annotation": "if there is any letter replace that with j",
            "best_program": "(lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $0 (lambda _j)))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef re2_train_67_if_there_is_any_letter_replace_that_with_j(arg1):\n    return f8(f8_0, arg1, lambda lx: 'j')"
        },
        {
            "annotation": "if there is any letter replace that with h s",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _s _h))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_68_if_there_is_any_letter_replace_that_with_h_s(arg1):\n    return f0(f0_0, arg1, 's', 'h')"
        },
        {
            "annotation": "if the word starts with any letter replace that with w i",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _i _w)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_71_if_the_word_starts_with_any_letter_replace_that_with_w_i(arg1):\n    f5_1 = f5(f5_0, arg1, 'i', 'w')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'i', 'w'), arg1)"
        },
        {
            "annotation": "if there is r replace that with j",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _r $0 _j))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_76_if_there_is_r_replace_that_with_j(arg1):\n    return f7(f7_0, 'r', arg1, 'j')"
        },
        {
            "annotation": "if there is t replace that with t x",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _t _t _x))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_77_if_there_is_t_replace_that_with_t_x(arg1):\n    return f4(f4_0, arg1, 't', 't', 'x')"
        },
        {
            "annotation": "if the word starts with any letter replace that with y w",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _w _y)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_78_if_the_word_starts_with_any_letter_replace_that_with_y_w(arg1):\n    f5_1 = f5(f5_0, arg1, 'w', 'y')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'w', 'y'), arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with c v",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _v _c)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_81_if_the_word_starts_with_any_letter_replace_that_with_c_v(arg1):\n    f5_1 = f5(f5_0, arg1, 'v', 'c')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'v', 'c'), arg1)"
        },
        {
            "annotation": "if there is b replace that with y a",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _b _y _a))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_88_if_there_is_b_replace_that_with_y_a(arg1):\n    return f4(f4_0, arg1, 'b', 'y', 'a')"
        },
        {
            "annotation": "if there is t replace that with d q",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _t _d _q))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_99_if_there_is_t_replace_that_with_d_q(arg1):\n    return f4(f4_0, arg1, 't', 'd', 'q')"
        },
        {
            "annotation": "if the word starts with any letter replace that with q a",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _a _q)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_103_if_the_word_starts_with_any_letter_replace_that_with_q_a(arg1):\n    f5_1 = f5(f5_0, arg1, 'a', 'q')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'a', 'q'), arg1)"
        },
        {
            "annotation": "if there is d replace that with c t",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _d _c _t))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_109_if_there_is_d_replace_that_with_c_t(arg1):\n    return f4(f4_0, arg1, 'd', 'c', 't')"
        },
        {
            "annotation": "if the word starts with any letter replace that with g a",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _a _g)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_111_if_the_word_starts_with_any_letter_replace_that_with_g_a(arg1):\n    f5_1 = f5(f5_0, arg1, 'a', 'g')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'a', 'g'), arg1)"
        },
        {
            "annotation": "if there is any letter replace that with p",
            "best_program": "(lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $0 (lambda _p)))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_113_if_there_is_any_letter_replace_that_with_p(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    map_1 = list(map(lambda lx: 'p', rsplit_1))\n    return \"\".join(map_1)",
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef re2_train_113_if_there_is_any_letter_replace_that_with_p(arg1):\n    return f8(f8_0, arg1, lambda lx: 'p')"
        },
        {
            "annotation": "if the word starts with consonant any letter replace that with f",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _o $0 $0 (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _e $0 $0 (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) (cdr $0) _rempty _f)))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f1(arg1, arg2, arg3, arg4):\n    rrevcdr_1 = arg1[:-1]\n    car_1 = rrevcdr_1[0]\n    rmatch_1 = __ismatch(car_1, arg2)\n    return arg1 if rmatch_1 else arg2\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_116_if_the_word_starts_with_consonant_any_letter_replace_that_with_f(arg1):\n    cdr_1 = arg1[1:]\n    f5_1 = f5(f5_0, cdr_1, '', 'f')\n    f1_1 = f1(f1_0, 'e', arg1, arg1, f5_1)\n    f1_2 = f1(f1_1, 'o', arg1, arg1, f1_1)\n    return f6(f6_0, lambda lx: f1(f1_1, 'o', lx, lx, f1_1), arg1)"
        },
        {
            "annotation": "if there is l replace that with n k",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _l _n _k))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_118_if_there_is_l_replace_that_with_n_k(arg1):\n    return f4(f4_0, arg1, 'l', 'n', 'k')"
        },
        {
            "annotation": "if there is t add y after that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _t _t _y))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_121_if_there_is_t_add_y_after_that(arg1):\n    return f4(f4_0, arg1, 't', 't', 'y')"
        },
        {
            "annotation": "if the word starts with any letter replace that with i r",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _r _i)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_127_if_the_word_starts_with_any_letter_replace_that_with_i_r(arg1):\n    f5_1 = f5(f5_0, arg1, 'r', 'i')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'r', 'i'), arg1)"
        },
        {
            "annotation": "if there is any letter replace that with r v",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _v _r))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_129_if_there_is_any_letter_replace_that_with_r_v(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    rconcat_1 = 'r' + 'v'\n    map_1 = list(map(lambda lx: rconcat_1, rsplit_1))\n    return \"\".join(map_1)",
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_129_if_there_is_any_letter_replace_that_with_r_v(arg1):\n    return f0(f0_0, arg1, 'v', 'r')"
        },
        {
            "annotation": "if the word ends with any letter consonant replace that with d t",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _t _d (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rrevcdr $0)) $0)))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_132_if_the_word_ends_with_any_letter_consonant_replace_that_with_d_t(arg1):\n    rrevcdr_1 = arg1[:-1]\n    f6_1 = f6(f6_0, lambda lx: lx[:-1], arg1)\n    return f3(f3_0, 't', 'd', f6_1)"
        },
        {
            "annotation": "if there is p add p after that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _p _p _p))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_133_if_there_is_p_add_p_after_that(arg1):\n    return f4(f4_0, arg1, 'p', 'p', 'p')"
        },
        {
            "annotation": "if the word starts with any letter add f before that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _f $0)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_134_if_the_word_starts_with_any_letter_add_f_before_that(arg1):\n    cons_1 = ['f'] + arg1\n    return f6(f6_0, lambda lx: ['f'] + lx, arg1)"
        },
        {
            "annotation": "if there is any letter replace that with f n",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _n _f))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_135_if_there_is_any_letter_replace_that_with_f_n(arg1):\n    return f0(f0_0, arg1, 'n', 'f')"
        },
        {
            "annotation": "if there is p replace that with g",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _p $0 _g))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_137_if_there_is_p_replace_that_with_g(arg1):\n    return f7(f7_0, 'p', arg1, 'g')"
        },
        {
            "annotation": "if the word ends with any letter add p after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend _p $0)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_144_if_the_word_ends_with_any_letter_add_p_after_that(arg1):\n    rappend_1 = arg1 + ['p']\n    return f6(f6_0, lambda lx: lx + ['p'], arg1)"
        },
        {
            "annotation": "if the word ends with s remove that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (if (_rmatch (_rtail $0) _s) (_rrevcdr $0) $0)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_150_if_the_word_ends_with_s_remove_that(arg1):\n    rrevcdr_1 = arg1[:-1]\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 's')\n    if_1 = rrevcdr_1 if rmatch_1 else arg1\n    return f6(f6_0, lambda lx: rrevcdr_1 if rmatch_1 else lx, arg1)"
        },
        {
            "annotation": "if there is r add b before that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _r _b _r))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_152_if_there_is_r_add_b_before_that(arg1):\n    return f4(f4_0, arg1, 'r', 'b', 'r')"
        },
        {
            "annotation": "if there is t replace that with f v",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _t _f _v))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_159_if_there_is_t_replace_that_with_f_v(arg1):\n    return f4(f4_0, arg1, 't', 'f', 'v')"
        },
        {
            "annotation": "if there is o replace that with c g",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _o _c _g))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_161_if_there_is_o_replace_that_with_c_g(arg1):\n    return f4(f4_0, arg1, 'o', 'c', 'g')"
        },
        {
            "annotation": "if there is m remove that",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _m $0 _rempty))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_162_if_there_is_m_remove_that(arg1):\n    return f7(f7_0, 'm', arg1, '')"
        },
        {
            "annotation": "if there is l replace that with v q",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _l _v _q))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_167_if_there_is_l_replace_that_with_v_q(arg1):\n    return f4(f4_0, arg1, 'l', 'v', 'q')"
        },
        {
            "annotation": "if the word starts with any letter replace that with b",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _b (cdr $0))) $0))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_169_if_the_word_starts_with_any_letter_replace_that_with_b(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    cdr_1 = rsplit_1[1:]\n    cons_1 = ['b'] + cdr_1\n    return \"\".join(cons_1)",
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_169_if_the_word_starts_with_any_letter_replace_that_with_b(arg1):\n    cdr_1 = arg1[1:]\n    cons_1 = ['b'] + cdr_1\n    return f6(f6_0, lambda lx: ['b'] + cdr_1, arg1)"
        },
        {
            "annotation": "if there is c replace that with k b",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _c _k _b))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_172_if_there_is_c_replace_that_with_k_b(arg1):\n    return f4(f4_0, arg1, 'c', 'k', 'b')"
        },
        {
            "annotation": "if there is n replace that with q",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _n $0 _q))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_176_if_there_is_n_replace_that_with_q(arg1):\n    return f7(f7_0, 'n', arg1, 'q')"
        },
        {
            "annotation": "if there is e replace that with t u",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _e _t _u))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_177_if_there_is_e_replace_that_with_t_u(arg1):\n    return f4(f4_0, arg1, 'e', 't', 'u')"
        },
        {
            "annotation": "if the word starts with any letter replace that with r m",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _m _r)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_183_if_the_word_starts_with_any_letter_replace_that_with_r_m(arg1):\n    f5_1 = f5(f5_0, arg1, 'm', 'r')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'm', 'r'), arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with b w",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _w _b)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_184_if_the_word_starts_with_any_letter_replace_that_with_b_w(arg1):\n    f5_1 = f5(f5_0, arg1, 'w', 'b')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'w', 'b'), arg1)"
        },
        {
            "annotation": "if the word ends with consonant replace that with a o",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _o _a $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_185_if_the_word_ends_with_consonant_replace_that_with_a_o(arg1):\n    return f3(f3_0, 'o', 'a', arg1)"
        },
        {
            "annotation": "if the word ends with any letter any letter add f after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend _f $0)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_190_if_the_word_ends_with_any_letter_any_letter_add_f_after_that(arg1):\n    rappend_1 = arg1 + ['f']\n    return f6(f6_0, lambda lx: lx + ['f'], arg1)"
        },
        {
            "annotation": "if the word starts with any letter add d after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _d (car $0))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_191_if_the_word_starts_with_any_letter_add_d_after_that(arg1):\n    car_1 = arg1[0]\n    f5_1 = f5(f5_0, arg1, 'd', car_1)\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'd', car_1), arg1)"
        },
        {
            "annotation": "if there is b replace that with q",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _b $0 _q))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_192_if_there_is_b_replace_that_with_q(arg1):\n    return f7(f7_0, 'b', arg1, 'q')"
        },
        {
            "annotation": "if there is n add e after that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _n _n _e))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_196_if_there_is_n_add_e_after_that(arg1):\n    return f4(f4_0, arg1, 'n', 'n', 'e')"
        },
        {
            "annotation": "if there is d add i after that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _d _d _i))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_199_if_there_is_d_add_i_after_that(arg1):\n    return f4(f4_0, arg1, 'd', 'd', 'i')"
        },
        {
            "annotation": "if the word starts with any letter replace that with f",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _f (cdr $0))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_203_if_the_word_starts_with_any_letter_replace_that_with_f(arg1):\n    cdr_1 = arg1[1:]\n    cons_1 = ['f'] + cdr_1\n    return f6(f6_0, lambda lx: ['f'] + cdr_1, arg1)"
        },
        {
            "annotation": "if the word starts with any letter any letter replace that with w",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _w (cdr (cdr $0)))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_208_if_the_word_starts_with_any_letter_any_letter_replace_that_with_w(arg1):\n    cdr_1 = arg1[1:]\n    cdr_2 = cdr_1[1:]\n    cons_1 = ['w'] + cdr_2\n    return f6(f6_0, lambda lx: ['w'] + cdr_2, arg1)"
        },
        {
            "annotation": "if the word ends with consonant replace that with w",
            "best_program": "(lambda (#(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend (if (_rmatch (_rtail $0) _e) _e $1) (_rrevcdr $0))))) _w $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f2(arg1, arg2):\n    rrevcdr_1 = arg1[:-1]\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 'e')\n    if_1 = 'e' if rmatch_1 else arg2\n    rappend_1 = rrevcdr_1 + [if_1]\n    return f6(f6_0, lambda lx: rrevcdr_1 + [if_1])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_216_if_the_word_ends_with_consonant_replace_that_with_w(arg1):\n    return f2(f2_0, 'w', arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with y c",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _c _y)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_217_if_the_word_starts_with_any_letter_replace_that_with_y_c(arg1):\n    f5_1 = f5(f5_0, arg1, 'c', 'y')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'c', 'y'), arg1)"
        },
        {
            "annotation": "if there is any letter replace that with y t",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _t _y))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_219_if_there_is_any_letter_replace_that_with_y_t(arg1):\n    return f0(f0_0, arg1, 't', 'y')"
        },
        {
            "annotation": "if there is any letter replace that with n i",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _i _n))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_223_if_there_is_any_letter_replace_that_with_n_i(arg1):\n    return f0(f0_0, arg1, 'i', 'n')"
        },
        {
            "annotation": "if there is any letter replace that with w t",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _t _w))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_229_if_there_is_any_letter_replace_that_with_w_t(arg1):\n    return f0(f0_0, arg1, 't', 'w')"
        },
        {
            "annotation": "if there is m replace that with l",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _m $0 _l))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_230_if_there_is_m_replace_that_with_l(arg1):\n    return f7(f7_0, 'm', arg1, 'l')"
        },
        {
            "annotation": "if the word ends with any letter replace that with i y",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _y _i $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_237_if_the_word_ends_with_any_letter_replace_that_with_i_y(arg1):\n    return f3(f3_0, 'y', 'i', arg1)"
        },
        {
            "annotation": "if the word starts with consonant replace that with g u",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _u $0 $0 (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _u _g))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f1(arg1, arg2, arg3, arg4):\n    rrevcdr_1 = arg1[:-1]\n    car_1 = rrevcdr_1[0]\n    rmatch_1 = __ismatch(car_1, arg2)\n    return arg1 if rmatch_1 else arg2\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_241_if_the_word_starts_with_consonant_replace_that_with_g_u(arg1):\n    f5_1 = f5(f5_0, arg1, 'u', 'g')\n    f1_1 = f1(f1_0, 'u', arg1, arg1, f5_1)\n    return f6(f6_0, lambda lx: f1(f1_0, 'u', lx, lx, f5_1), arg1)"
        },
        {
            "annotation": "if there is c add u before that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _c _u _c))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_243_if_there_is_c_add_u_before_that(arg1):\n    return f4(f4_0, arg1, 'c', 'u', 'c')"
        },
        {
            "annotation": "if there is any letter replace that with u e",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _e _u))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_244_if_there_is_any_letter_replace_that_with_u_e(arg1):\n    return f0(f0_0, arg1, 'e', 'u')"
        },
        {
            "annotation": "if there is t replace that with n",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _t $0 _n))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_246_if_there_is_t_replace_that_with_n(arg1):\n    return f7(f7_0, 't', arg1, 'n')"
        },
        {
            "annotation": "if there is s add x after that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _s _s _x))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_250_if_there_is_s_add_x_after_that(arg1):\n    return f4(f4_0, arg1, 's', 's', 'x')"
        },
        {
            "annotation": "if there is e replace that with i m",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _e _i _m))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_252_if_there_is_e_replace_that_with_i_m(arg1):\n    return f4(f4_0, arg1, 'e', 'i', 'm')"
        },
        {
            "annotation": "if the word ends with e any letter replace that with t",
            "best_program": "(lambda (if (_rmatch (_rtail (_rrevcdr (_rsplit _rempty $0))) _e) (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend _t (_rrevcdr (_rrevcdr $0)))) $0) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_255_if_the_word_ends_with_e_any_letter_replace_that_with_t(arg1):\n    rrevcdr_1 = arg1[:-1]\n    rrevcdr_2 = rrevcdr_1[:-1]\n    rappend_1 = rrevcdr_2 + ['t']\n    f6_1 = f6(f6_0, lambda lx: rrevcdr_2 + ['t'], arg1)\n    rsplit_1 = __regex_split('', arg1)\n    rrevcdr_3 = rsplit_1[:-1]\n    rtail_1 = rrevcdr_3[-1]\n    rmatch_1 = __ismatch(rtail_1, 'e')\n    return f6_1 if rmatch_1 else arg1"
        },
        {
            "annotation": "if the word ends with consonant replace that with w i",
            "best_program": "(lambda (#(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend (if (_rmatch (_rtail $0) _e) _e $1) (_rrevcdr $0))))) (_rconcat _w _i) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f2(arg1, arg2):\n    rrevcdr_1 = arg1[:-1]\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 'e')\n    if_1 = 'e' if rmatch_1 else arg2\n    rappend_1 = rrevcdr_1 + [if_1]\n    return f6(f6_0, lambda lx: rrevcdr_1 + [if_1])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_256_if_the_word_ends_with_consonant_replace_that_with_w_i(arg1):\n    rconcat_1 = 'w' + 'i'\n    return f2(f2_0, rconcat_1, arg1)"
        },
        {
            "annotation": "if the word starts with any letter any letter add y before that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _y $0)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_261_if_the_word_starts_with_any_letter_any_letter_add_y_before_that(arg1):\n    cons_1 = ['y'] + arg1\n    return f6(f6_0, lambda lx: ['y'] + lx, arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with k e",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _e _k)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_264_if_the_word_starts_with_any_letter_replace_that_with_k_e(arg1):\n    f5_1 = f5(f5_0, arg1, 'e', 'k')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'e', 'k'), arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with h",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _h (cdr $0))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_265_if_the_word_starts_with_any_letter_replace_that_with_h(arg1):\n    cdr_1 = arg1[1:]\n    cons_1 = ['h'] + cdr_1\n    return f6(f6_0, lambda lx: ['h'] + cdr_1, arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with x e",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _e _x)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_268_if_the_word_starts_with_any_letter_replace_that_with_x_e(arg1):\n    f5_1 = f5(f5_0, arg1, 'e', 'x')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'e', 'x'), arg1)"
        },
        {
            "annotation": "if there is r replace that with m l",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _r _m _l))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_269_if_there_is_r_replace_that_with_m_l(arg1):\n    return f4(f4_0, arg1, 'r', 'm', 'l')"
        },
        {
            "annotation": "if there is r replace that with e d",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _r _e _d))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_270_if_there_is_r_replace_that_with_e_d(arg1):\n    return f4(f4_0, arg1, 'r', 'e', 'd')"
        },
        {
            "annotation": "if there is c add e after that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _c _c _e))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_271_if_there_is_c_add_e_after_that(arg1):\n    return f4(f4_0, arg1, 'c', 'c', 'e')"
        },
        {
            "annotation": "if the word ends with consonant replace that with r",
            "best_program": "(lambda (#(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend (if (_rmatch (_rtail $0) _e) _e $1) (_rrevcdr $0))))) _r $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f2(arg1, arg2):\n    rrevcdr_1 = arg1[:-1]\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 'e')\n    if_1 = 'e' if rmatch_1 else arg2\n    rappend_1 = rrevcdr_1 + [if_1]\n    return f6(f6_0, lambda lx: rrevcdr_1 + [if_1])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_275_if_the_word_ends_with_consonant_replace_that_with_r(arg1):\n    return f2(f2_0, 'r', arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with m i",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _i _m)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_276_if_the_word_starts_with_any_letter_replace_that_with_m_i(arg1):\n    f5_1 = f5(f5_0, arg1, 'i', 'm')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'i', 'm'), arg1)"
        },
        {
            "annotation": "if the word ends with consonant replace that with o c",
            "best_program": "(lambda (#(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend (if (_rmatch (_rtail $0) _e) _e $1) (_rrevcdr $0))))) (_rconcat _o _c) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f2(arg1, arg2):\n    rrevcdr_1 = arg1[:-1]\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 'e')\n    if_1 = 'e' if rmatch_1 else arg2\n    rappend_1 = rrevcdr_1 + [if_1]\n    return f6(f6_0, lambda lx: rrevcdr_1 + [if_1])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_279_if_the_word_ends_with_consonant_replace_that_with_o_c(arg1):\n    rconcat_1 = 'o' + 'c'\n    return f2(f2_0, rconcat_1, arg1)"
        },
        {
            "annotation": "if there is any letter add q before that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $0 (lambda (_rconcat _q $0))))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef re2_train_280_if_there_is_any_letter_add_q_before_that(arg1):\n    rconcat_1 = 'q' + arg1\n    return f8(f8_0, arg1, lambda lx: 'q' + lx)"
        },
        {
            "annotation": "if the word starts with any letter replace that with j o",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _o _j)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_289_if_the_word_starts_with_any_letter_replace_that_with_j_o(arg1):\n    f5_1 = f5(f5_0, arg1, 'o', 'j')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'o', 'j'), arg1)"
        },
        {
            "annotation": "if the word ends with consonant add j after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _o $0 _rempty _j) $0)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f1(arg1, arg2, arg3, arg4):\n    rrevcdr_1 = arg1[:-1]\n    car_1 = rrevcdr_1[0]\n    rmatch_1 = __ismatch(car_1, arg2)\n    return arg1 if rmatch_1 else arg2\n\ndef re2_train_293_if_the_word_ends_with_consonant_add_j_after_that(arg1):\n    f1_1 = f1(f1_0, 'o', arg1, '', 'j')\n    rappend_1 = arg1 + [f1_1]\n    return f6(f6_0, lambda lx: lx + [f1_1], arg1)"
        },
        {
            "annotation": "if there is s replace that with t q",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _s _t _q))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_296_if_there_is_s_replace_that_with_t_q(arg1):\n    return f4(f4_0, arg1, 's', 't', 'q')"
        },
        {
            "annotation": "if the word ends with consonant add p after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (if (_rmatch (_rtail $0) _e) $0 (_rappend _p $0))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_298_if_the_word_ends_with_consonant_add_p_after_that(arg1):\n    rappend_1 = arg1 + ['p']\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 'e')\n    if_1 = arg1 if rmatch_1 else rappend_1\n    return f6(f6_0, lambda lx: lx if rmatch_1 else rappend_1, arg1)"
        },
        {
            "annotation": "if there is any letter replace that with g i",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _i _g))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_299_if_there_is_any_letter_replace_that_with_g_i(arg1):\n    return f0(f0_0, arg1, 'i', 'g')"
        },
        {
            "annotation": "if the word ends with any letter replace that with o m",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _m _o $0))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_307_if_the_word_ends_with_any_letter_replace_that_with_o_m(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    rrevcdr_1 = rsplit_1[:-1]\n    rappend_1 = rrevcdr_1 + ['o']\n    rappend_2 = rappend_1 + ['m']\n    return \"\".join(rappend_2)",
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_307_if_the_word_ends_with_any_letter_replace_that_with_o_m(arg1):\n    return f3(f3_0, 'm', 'o', arg1)"
        },
        {
            "annotation": "if the word ends with consonant replace that with n a",
            "best_program": "(lambda (#(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend (if (_rmatch (_rtail $0) _e) _e $1) (_rrevcdr $0))))) (_rconcat _n _a) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f2(arg1, arg2):\n    rrevcdr_1 = arg1[:-1]\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 'e')\n    if_1 = 'e' if rmatch_1 else arg2\n    rappend_1 = rrevcdr_1 + [if_1]\n    return f6(f6_0, lambda lx: rrevcdr_1 + [if_1])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_309_if_the_word_ends_with_consonant_replace_that_with_n_a(arg1):\n    rconcat_1 = 'n' + 'a'\n    return f2(f2_0, rconcat_1, arg1)"
        },
        {
            "annotation": "if there is g replace that with k a",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _g _k _a))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_311_if_there_is_g_replace_that_with_k_a(arg1):\n    return f4(f4_0, arg1, 'g', 'k', 'a')"
        },
        {
            "annotation": "if there is any letter replace that with h x",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _x _h))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_312_if_there_is_any_letter_replace_that_with_h_x(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    rconcat_1 = 'h' + 'x'\n    map_1 = list(map(lambda lx: rconcat_1, rsplit_1))\n    return \"\".join(map_1)",
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_312_if_there_is_any_letter_replace_that_with_h_x(arg1):\n    return f0(f0_0, arg1, 'x', 'h')"
        },
        {
            "annotation": "if the word starts with any letter replace that with r r",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _r _r)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_316_if_the_word_starts_with_any_letter_replace_that_with_r_r(arg1):\n    f5_1 = f5(f5_0, arg1, 'r', 'r')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'r', 'r'), arg1)"
        },
        {
            "annotation": "if there is g replace that with c",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _g $0 _c))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_319_if_there_is_g_replace_that_with_c(arg1):\n    return f7(f7_0, 'g', arg1, 'c')"
        },
        {
            "annotation": "if the word starts with any letter replace that with g b",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _b _g)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_322_if_the_word_starts_with_any_letter_replace_that_with_g_b(arg1):\n    f5_1 = f5(f5_0, arg1, 'b', 'g')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'b', 'g'), arg1)"
        },
        {
            "annotation": "if there is t replace that with i",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _t $0 _i))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_325_if_there_is_t_replace_that_with_i(arg1):\n    return f7(f7_0, 't', arg1, 'i')"
        },
        {
            "annotation": "if the word starts with consonant replace that with i",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _i (cdr $0))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_327_if_the_word_starts_with_consonant_replace_that_with_i(arg1):\n    cdr_1 = arg1[1:]\n    cons_1 = ['i'] + cdr_1\n    return f6(f6_0, lambda lx: ['i'] + cdr_1, arg1)"
        },
        {
            "annotation": "if there is t replace that with l p",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _t _l _p))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_330_if_there_is_t_replace_that_with_l_p(arg1):\n    return f4(f4_0, arg1, 't', 'l', 'p')"
        },
        {
            "annotation": "if the word ends with consonant replace that with o g",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _g _o $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_331_if_the_word_ends_with_consonant_replace_that_with_o_g(arg1):\n    return f3(f3_0, 'g', 'o', arg1)"
        },
        {
            "annotation": "if the word starts with consonant any letter replace that with e a",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) (cdr $0) _a _e)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_341_if_the_word_starts_with_consonant_any_letter_replace_that_with_e_a(arg1):\n    cdr_1 = arg1[1:]\n    f5_1 = f5(f5_0, cdr_1, 'a', 'e')\n    return f6(f6_0, lambda lx: f5(f5_0, cdr_1, 'a', 'e'), arg1)"
        },
        {
            "annotation": "if the word ends with any letter add q after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend _q $0)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_344_if_the_word_ends_with_any_letter_add_q_after_that(arg1):\n    rappend_1 = arg1 + ['q']\n    return f6(f6_0, lambda lx: lx + ['q'], arg1)"
        },
        {
            "annotation": "if the word starts with consonant replace that with i s",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _s _i)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_354_if_the_word_starts_with_consonant_replace_that_with_i_s(arg1):\n    f5_1 = f5(f5_0, arg1, 's', 'i')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 's', 'i'), arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with g l",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _l _g)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_355_if_the_word_starts_with_any_letter_replace_that_with_g_l(arg1):\n    f5_1 = f5(f5_0, arg1, 'l', 'g')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'l', 'g'), arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with m",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _m (cdr $0))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_356_if_the_word_starts_with_any_letter_replace_that_with_m(arg1):\n    cdr_1 = arg1[1:]\n    cons_1 = ['m'] + cdr_1\n    return f6(f6_0, lambda lx: ['m'] + cdr_1, arg1)"
        },
        {
            "annotation": "if there is i replace that with m",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _i $0 _m))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_357_if_there_is_i_replace_that_with_m(arg1):\n    return f7(f7_0, 'i', arg1, 'm')"
        },
        {
            "annotation": "if there is any letter replace that with j u",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _u _j))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_358_if_there_is_any_letter_replace_that_with_j_u(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    rconcat_1 = 'j' + 'u'\n    map_1 = list(map(lambda lx: rconcat_1, rsplit_1))\n    return \"\".join(map_1)",
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_358_if_there_is_any_letter_replace_that_with_j_u(arg1):\n    return f0(f0_0, arg1, 'u', 'j')"
        },
        {
            "annotation": "if there is s replace that with d u",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _s _d _u))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_360_if_there_is_s_replace_that_with_d_u(arg1):\n    return f4(f4_0, arg1, 's', 'd', 'u')"
        },
        {
            "annotation": "if the word ends with consonant replace that with i u",
            "best_program": "(lambda (#(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend (if (_rmatch (_rtail $0) _e) _e $1) (_rrevcdr $0))))) (_rconcat _i _u) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f2(arg1, arg2):\n    rrevcdr_1 = arg1[:-1]\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 'e')\n    if_1 = 'e' if rmatch_1 else arg2\n    rappend_1 = rrevcdr_1 + [if_1]\n    return f6(f6_0, lambda lx: rrevcdr_1 + [if_1])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_367_if_the_word_ends_with_consonant_replace_that_with_i_u(arg1):\n    rconcat_1 = 'i' + 'u'\n    return f2(f2_0, rconcat_1, arg1)"
        },
        {
            "annotation": "if there is p replace that with a w",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _p _a _w))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_371_if_there_is_p_replace_that_with_a_w(arg1):\n    return f4(f4_0, arg1, 'p', 'a', 'w')"
        },
        {
            "annotation": "if there is g replace that with u f",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _g _u _f))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_372_if_there_is_g_replace_that_with_u_f(arg1):\n    return f4(f4_0, arg1, 'g', 'u', 'f')"
        },
        {
            "annotation": "if the word starts with any letter replace that with a w",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _w _a)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_375_if_the_word_starts_with_any_letter_replace_that_with_a_w(arg1):\n    f5_1 = f5(f5_0, arg1, 'w', 'a')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'w', 'a'), arg1)"
        },
        {
            "annotation": "if the word ends with any letter replace that with r j",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _j _r $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_377_if_the_word_ends_with_any_letter_replace_that_with_r_j(arg1):\n    return f3(f3_0, 'j', 'r', arg1)"
        },
        {
            "annotation": "if there is any letter replace that with i p",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _p _i))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_378_if_there_is_any_letter_replace_that_with_i_p(arg1):\n    return f0(f0_0, arg1, 'p', 'i')"
        },
        {
            "annotation": "if there is any letter replace that with n g",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _g _n))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_381_if_there_is_any_letter_replace_that_with_n_g(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    rconcat_1 = 'n' + 'g'\n    map_1 = list(map(lambda lx: rconcat_1, rsplit_1))\n    return \"\".join(map_1)",
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_381_if_there_is_any_letter_replace_that_with_n_g(arg1):\n    return f0(f0_0, arg1, 'g', 'n')"
        },
        {
            "annotation": "if the word starts with any letter add o after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _o (car $0))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_382_if_the_word_starts_with_any_letter_add_o_after_that(arg1):\n    car_1 = arg1[0]\n    f5_1 = f5(f5_0, arg1, 'o', car_1)\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'o', car_1), arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with x i",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _i _x)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_385_if_the_word_starts_with_any_letter_replace_that_with_x_i(arg1):\n    f5_1 = f5(f5_0, arg1, 'i', 'x')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'i', 'x'), arg1)"
        },
        {
            "annotation": "if the word starts with consonant replace that with q i",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _i _q)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_388_if_the_word_starts_with_consonant_replace_that_with_q_i(arg1):\n    f5_1 = f5(f5_0, arg1, 'i', 'q')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'i', 'q'), arg1)"
        },
        {
            "annotation": "if the word ends with any letter any letter replace that with j",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend _j (_rrevcdr (_rrevcdr $0)))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_390_if_the_word_ends_with_any_letter_any_letter_replace_that_with_j(arg1):\n    rrevcdr_1 = arg1[:-1]\n    rrevcdr_2 = rrevcdr_1[:-1]\n    rappend_1 = rrevcdr_2 + ['j']\n    return f6(f6_0, lambda lx: rrevcdr_2 + ['j'], arg1)"
        },
        {
            "annotation": "if the word ends with consonant replace that with i",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend _i (_rrevcdr $0))) $0))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_393_if_the_word_ends_with_consonant_replace_that_with_i(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    rrevcdr_1 = rsplit_1[:-1]\n    rappend_1 = rrevcdr_1 + ['i']\n    return \"\".join(rappend_1)",
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_393_if_the_word_ends_with_consonant_replace_that_with_i(arg1):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + ['i']\n    return f6(f6_0, lambda lx: rrevcdr_1 + ['i'], arg1)"
        },
        {
            "annotation": "if there is t replace that with k",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _t $0 _k))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_394_if_there_is_t_replace_that_with_k(arg1):\n    return f7(f7_0, 't', arg1, 'k')"
        },
        {
            "annotation": "if the word starts with any letter replace that with e s",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _s _e)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_395_if_the_word_starts_with_any_letter_replace_that_with_e_s(arg1):\n    f5_1 = f5(f5_0, arg1, 's', 'e')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 's', 'e'), arg1)"
        },
        {
            "annotation": "if there is s replace that with h",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _s $0 _h))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_397_if_there_is_s_replace_that_with_h(arg1):\n    return f7(f7_0, 's', arg1, 'h')"
        },
        {
            "annotation": "if there is r add q after that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _r _r _q))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_401_if_there_is_r_add_q_after_that(arg1):\n    return f4(f4_0, arg1, 'r', 'r', 'q')"
        },
        {
            "annotation": "if there is u replace that with b",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _u $0 _b))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_404_if_there_is_u_replace_that_with_b(arg1):\n    return f7(f7_0, 'u', arg1, 'b')"
        },
        {
            "annotation": "if the word starts with any letter any letter replace that with e s",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) (cdr $0) _s _e)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_407_if_the_word_starts_with_any_letter_any_letter_replace_that_with_e_s(arg1):\n    cdr_1 = arg1[1:]\n    f5_1 = f5(f5_0, cdr_1, 's', 'e')\n    return f6(f6_0, lambda lx: f5(f5_0, cdr_1, 's', 'e'), arg1)"
        },
        {
            "annotation": "if there is r replace that with v a",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _r _v _a))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_411_if_there_is_r_replace_that_with_v_a(arg1):\n    return f4(f4_0, arg1, 'r', 'v', 'a')"
        },
        {
            "annotation": "if there is i replace that with v",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _i $0 _v))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_414_if_there_is_i_replace_that_with_v(arg1):\n    return f7(f7_0, 'i', arg1, 'v')"
        },
        {
            "annotation": "if there is any letter add l before that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $0 (lambda (_rconcat _l $0))))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef re2_train_417_if_there_is_any_letter_add_l_before_that(arg1):\n    rconcat_1 = 'l' + arg1\n    return f8(f8_0, arg1, lambda lx: 'l' + lx)"
        },
        {
            "annotation": "if the word ends with consonant replace that with o y",
            "best_program": "(lambda (#(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend (if (_rmatch (_rtail $0) _e) _e $1) (_rrevcdr $0))))) (_rconcat _o _y) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f2(arg1, arg2):\n    rrevcdr_1 = arg1[:-1]\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 'e')\n    if_1 = 'e' if rmatch_1 else arg2\n    rappend_1 = rrevcdr_1 + [if_1]\n    return f6(f6_0, lambda lx: rrevcdr_1 + [if_1])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_420_if_the_word_ends_with_consonant_replace_that_with_o_y(arg1):\n    rconcat_1 = 'o' + 'y'\n    return f2(f2_0, rconcat_1, arg1)"
        },
        {
            "annotation": "if the word starts with any letter any letter replace that with f s",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) (cdr $0) _s _f)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_427_if_the_word_starts_with_any_letter_any_letter_replace_that_with_f_s(arg1):\n    cdr_1 = arg1[1:]\n    f5_1 = f5(f5_0, cdr_1, 's', 'f')\n    return f6(f6_0, lambda lx: f5(f5_0, cdr_1, 's', 'f'), arg1)"
        },
        {
            "annotation": "if the word starts with any letter any letter replace that with q",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _q (cdr (cdr $0)))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_428_if_the_word_starts_with_any_letter_any_letter_replace_that_with_q(arg1):\n    cdr_1 = arg1[1:]\n    cdr_2 = cdr_1[1:]\n    cons_1 = ['q'] + cdr_2\n    return f6(f6_0, lambda lx: ['q'] + cdr_2, arg1)"
        },
        {
            "annotation": "if the word ends with any letter any letter replace that with r q",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _q _r (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rrevcdr $0)) $0)))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_429_if_the_word_ends_with_any_letter_any_letter_replace_that_with_r_q(arg1):\n    rrevcdr_1 = arg1[:-1]\n    f6_1 = f6(f6_0, lambda lx: lx[:-1], arg1)\n    return f3(f3_0, 'q', 'r', f6_1)"
        },
        {
            "annotation": "if the word ends with any letter any letter replace that with b j",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend _j (_rappend _b (_rrevcdr (_rrevcdr $0))))) $0))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_434_if_the_word_ends_with_any_letter_any_letter_replace_that_with_b_j(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    rrevcdr_1 = rsplit_1[:-1]\n    rrevcdr_2 = rrevcdr_1[:-1]\n    rappend_1 = rrevcdr_2 + ['b']\n    rappend_2 = rappend_1 + ['j']\n    return \"\".join(rappend_2)",
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_434_if_the_word_ends_with_any_letter_any_letter_replace_that_with_b_j(arg1):\n    rrevcdr_1 = arg1[:-1]\n    rrevcdr_2 = rrevcdr_1[:-1]\n    rappend_1 = rrevcdr_2 + ['b']\n    rappend_2 = rappend_1 + ['j']\n    return f6(f6_0, lambda lx: rappend_1 + ['j'], arg1)"
        },
        {
            "annotation": "if there is c replace that with n m",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _c _n _m))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_439_if_there_is_c_replace_that_with_n_m(arg1):\n    return f4(f4_0, arg1, 'c', 'n', 'm')"
        },
        {
            "annotation": "if there is any letter add b after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $0 (lambda (_rconcat $0 _b))))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef re2_train_441_if_there_is_any_letter_add_b_after_that(arg1):\n    rconcat_1 = arg1 + 'b'\n    return f8(f8_0, arg1, lambda lx: lx + 'b')"
        },
        {
            "annotation": "if there is any letter replace that with h r",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _r _h))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_442_if_there_is_any_letter_replace_that_with_h_r(arg1):\n    return f0(f0_0, arg1, 'r', 'h')"
        },
        {
            "annotation": "if the word ends with any letter add k after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend _k $0)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_443_if_the_word_ends_with_any_letter_add_k_after_that(arg1):\n    rappend_1 = arg1 + ['k']\n    return f6(f6_0, lambda lx: lx + ['k'], arg1)"
        },
        {
            "annotation": "if the word ends with any letter replace that with x s",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _s _x $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_445_if_the_word_ends_with_any_letter_replace_that_with_x_s(arg1):\n    return f3(f3_0, 's', 'x', arg1)"
        },
        {
            "annotation": "if there is d replace that with a v",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _d _a _v))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_449_if_there_is_d_replace_that_with_a_v(arg1):\n    return f4(f4_0, arg1, 'd', 'a', 'v')"
        },
        {
            "annotation": "if the word ends with any letter consonant replace that with j",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend _j (_rrevcdr (_rrevcdr $0)))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_450_if_the_word_ends_with_any_letter_consonant_replace_that_with_j(arg1):\n    rrevcdr_1 = arg1[:-1]\n    rrevcdr_2 = rrevcdr_1[:-1]\n    rappend_1 = rrevcdr_2 + ['j']\n    return f6(f6_0, lambda lx: rrevcdr_2 + ['j'], arg1)"
        },
        {
            "annotation": "if the word starts with any letter e replace that with m",
            "best_program": "(lambda (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _e (cdr (_rsplit _rempty $0)) (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) (cdr $0) _rempty _m)) $0) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f1(arg1, arg2, arg3, arg4):\n    rrevcdr_1 = arg1[:-1]\n    car_1 = rrevcdr_1[0]\n    rmatch_1 = __ismatch(car_1, arg2)\n    return arg1 if rmatch_1 else arg2\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_451_if_the_word_starts_with_any_letter_e_replace_that_with_m(arg1):\n    cdr_1 = arg1[1:]\n    f5_1 = f5(f5_0, cdr_1, '', 'm')\n    f6_1 = f6(f6_0, lambda lx: f5(f5_0, cdr_1, '', 'm'), arg1)\n    rsplit_1 = __regex_split('', arg1)\n    cdr_2 = rsplit_1[1:]\n    return f1(f1_0, 'e', cdr_2, f6_1, arg1)"
        },
        {
            "annotation": "if the word ends with any letter any letter add a after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend _a $0)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_462_if_the_word_ends_with_any_letter_any_letter_add_a_after_that(arg1):\n    rappend_1 = arg1 + ['a']\n    return f6(f6_0, lambda lx: lx + ['a'], arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with a",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _a (cdr $0))) $0))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_463_if_the_word_starts_with_any_letter_replace_that_with_a(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    cdr_1 = rsplit_1[1:]\n    cons_1 = ['a'] + cdr_1\n    return \"\".join(cons_1)",
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_463_if_the_word_starts_with_any_letter_replace_that_with_a(arg1):\n    cdr_1 = arg1[1:]\n    cons_1 = ['a'] + cdr_1\n    return f6(f6_0, lambda lx: ['a'] + cdr_1, arg1)"
        },
        {
            "annotation": "if the word ends with any letter add u after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend _u $0)) $0))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_466_if_the_word_ends_with_any_letter_add_u_after_that(arg1):\n    rsplit_1 = __regex_split('i', arg1)\n    rappend_1 = rsplit_1 + ['u']\n    return \"\".join(rappend_1)",
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_466_if_the_word_ends_with_any_letter_add_u_after_that(arg1):\n    rappend_1 = arg1 + ['u']\n    return f6(f6_0, lambda lx: lx + ['u'], arg1)"
        },
        {
            "annotation": "if the word ends with any letter replace that with x p",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _p _x $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_468_if_the_word_ends_with_any_letter_replace_that_with_x_p(arg1):\n    return f3(f3_0, 'p', 'x', arg1)"
        },
        {
            "annotation": "if there is p add o after that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _p _p _o))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_469_if_there_is_p_add_o_after_that(arg1):\n    return f4(f4_0, arg1, 'p', 'p', 'o')"
        },
        {
            "annotation": "if there is o add r before that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _o _r _o))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_471_if_there_is_o_add_r_before_that(arg1):\n    return f4(f4_0, arg1, 'o', 'r', 'o')"
        },
        {
            "annotation": "if the word starts with any letter add v before that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _v $0)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_472_if_the_word_starts_with_any_letter_add_v_before_that(arg1):\n    cons_1 = ['v'] + arg1\n    return f6(f6_0, lambda lx: ['v'] + lx, arg1)"
        },
        {
            "annotation": "if there is o replace that with l",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _o $0 _l))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_473_if_there_is_o_replace_that_with_l(arg1):\n    return f7(f7_0, 'o', arg1, 'l')"
        },
        {
            "annotation": "if there is t replace that with o",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _t $0 _o))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_474_if_there_is_t_replace_that_with_o(arg1):\n    return f7(f7_0, 't', arg1, 'o')"
        },
        {
            "annotation": "if there is s replace that with i r",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _s _i _r))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_477_if_there_is_s_replace_that_with_i_r(arg1):\n    return f4(f4_0, arg1, 's', 'i', 'r')"
        },
        {
            "annotation": "if the word ends with consonant replace that with b a",
            "best_program": "(lambda (#(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend (if (_rmatch (_rtail $0) _e) _e $1) (_rrevcdr $0))))) (_rconcat _b _a) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f2(arg1, arg2):\n    rrevcdr_1 = arg1[:-1]\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 'e')\n    if_1 = 'e' if rmatch_1 else arg2\n    rappend_1 = rrevcdr_1 + [if_1]\n    return f6(f6_0, lambda lx: rrevcdr_1 + [if_1])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_483_if_the_word_ends_with_consonant_replace_that_with_b_a(arg1):\n    rconcat_1 = 'b' + 'a'\n    return f2(f2_0, rconcat_1, arg1)"
        },
        {
            "annotation": "if the word ends with consonant replace that with j q",
            "best_program": "(lambda (#(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend (if (_rmatch (_rtail $0) _e) _e $1) (_rrevcdr $0))))) (_rconcat _j _q) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f2(arg1, arg2):\n    rrevcdr_1 = arg1[:-1]\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 'e')\n    if_1 = 'e' if rmatch_1 else arg2\n    rappend_1 = rrevcdr_1 + [if_1]\n    return f6(f6_0, lambda lx: rrevcdr_1 + [if_1])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_484_if_the_word_ends_with_consonant_replace_that_with_j_q(arg1):\n    rconcat_1 = 'j' + 'q'\n    return f2(f2_0, rconcat_1, arg1)"
        },
        {
            "annotation": "if there is l add m before that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _l _m _l))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_485_if_there_is_l_add_m_before_that(arg1):\n    return f4(f4_0, arg1, 'l', 'm', 'l')"
        },
        {
            "annotation": "if the word starts with any letter add b before that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _b $0)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_486_if_the_word_starts_with_any_letter_add_b_before_that(arg1):\n    cons_1 = ['b'] + arg1\n    return f6(f6_0, lambda lx: ['b'] + lx, arg1)"
        },
        {
            "annotation": "if the word starts with consonant add a before that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _a $0)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_487_if_the_word_starts_with_consonant_add_a_before_that(arg1):\n    cons_1 = ['a'] + arg1\n    return f6(f6_0, lambda lx: ['a'] + lx, arg1)"
        },
        {
            "annotation": "if there is any letter replace that with l",
            "best_program": "(lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $0 (lambda _l)))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef re2_train_490_if_there_is_any_letter_replace_that_with_l(arg1):\n    return f8(f8_0, arg1, lambda lx: 'l')"
        },
        {
            "annotation": "if the word ends with any letter replace that with o j",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _j _o $0))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_491_if_the_word_ends_with_any_letter_replace_that_with_o_j(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    rrevcdr_1 = rsplit_1[:-1]\n    rappend_1 = rrevcdr_1 + ['o']\n    rappend_2 = rappend_1 + ['j']\n    return \"\".join(rappend_2)",
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_491_if_the_word_ends_with_any_letter_replace_that_with_o_j(arg1):\n    return f3(f3_0, 'j', 'o', arg1)"
        },
        {
            "annotation": "if there is s replace that with r a",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _s _r _a))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_493_if_there_is_s_replace_that_with_r_a(arg1):\n    return f4(f4_0, arg1, 's', 'r', 'a')"
        },
        {
            "annotation": "if the word starts with any letter replace that with s b",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _b _s)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_494_if_the_word_starts_with_any_letter_replace_that_with_s_b(arg1):\n    f5_1 = f5(f5_0, arg1, 'b', 's')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'b', 's'), arg1)"
        },
        {
            "annotation": "if the word ends with any letter replace that with c v",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _v _c $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_495_if_the_word_ends_with_any_letter_replace_that_with_c_v(arg1):\n    return f3(f3_0, 'v', 'c', arg1)"
        },
        {
            "annotation": "if there is e replace that with p",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _e $0 _p))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_504_if_there_is_e_replace_that_with_p(arg1):\n    return f7(f7_0, 'e', arg1, 'p')"
        },
        {
            "annotation": "if the word ends with s add x after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (if (_rmatch (_rtail $0) _s) (_rappend _x $0) $0)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_507_if_the_word_ends_with_s_add_x_after_that(arg1):\n    rappend_1 = arg1 + ['x']\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 's')\n    if_1 = rappend_1 if rmatch_1 else arg1\n    return f6(f6_0, lambda lx: rappend_1 if rmatch_1 else lx, arg1)"
        },
        {
            "annotation": "if the word starts with any letter a replace that with q d",
            "best_program": "(lambda (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _a (cdr (_rsplit _rempty $0)) (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) (cdr $0) _d _q)) $0) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f1(arg1, arg2, arg3, arg4):\n    rrevcdr_1 = arg1[:-1]\n    car_1 = rrevcdr_1[0]\n    rmatch_1 = __ismatch(car_1, arg2)\n    return arg1 if rmatch_1 else arg2\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_509_if_the_word_starts_with_any_letter_a_replace_that_with_q_d(arg1):\n    cdr_1 = arg1[1:]\n    f5_1 = f5(f5_0, cdr_1, 'd', 'q')\n    f6_1 = f6(f6_0, lambda lx: f5(f5_0, cdr_1, 'd', 'q'), arg1)\n    rsplit_1 = __regex_split('', arg1)\n    cdr_2 = rsplit_1[1:]\n    return f1(f1_0, 'a', cdr_2, f6_1, arg1)"
        },
        {
            "annotation": "if the word ends with any letter replace that with b a",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _a _b $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_513_if_the_word_ends_with_any_letter_replace_that_with_b_a(arg1):\n    return f3(f3_0, 'a', 'b', arg1)"
        },
        {
            "annotation": "if there is r replace that with g e",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _r _g _e))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_514_if_there_is_r_replace_that_with_g_e(arg1):\n    return f4(f4_0, arg1, 'r', 'g', 'e')"
        },
        {
            "annotation": "if there is d replace that with p",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _d $0 _p))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_521_if_there_is_d_replace_that_with_p(arg1):\n    return f7(f7_0, 'd', arg1, 'p')"
        },
        {
            "annotation": "if there is any letter replace that with f h",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _h _f))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_522_if_there_is_any_letter_replace_that_with_f_h(arg1):\n    return f0(f0_0, arg1, 'h', 'f')"
        },
        {
            "annotation": "if the word ends with consonant replace that with x i",
            "best_program": "(lambda (#(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend (if (_rmatch (_rtail $0) _e) _e $1) (_rrevcdr $0))))) (_rconcat _x _i) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f2(arg1, arg2):\n    rrevcdr_1 = arg1[:-1]\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 'e')\n    if_1 = 'e' if rmatch_1 else arg2\n    rappend_1 = rrevcdr_1 + [if_1]\n    return f6(f6_0, lambda lx: rrevcdr_1 + [if_1])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_523_if_the_word_ends_with_consonant_replace_that_with_x_i(arg1):\n    rconcat_1 = 'x' + 'i'\n    return f2(f2_0, rconcat_1, arg1)"
        },
        {
            "annotation": "if the word ends with any letter any letter replace that with t w",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend _w (_rappend _t (_rrevcdr (_rrevcdr $0))))) $0))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_526_if_the_word_ends_with_any_letter_any_letter_replace_that_with_t_w(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    rrevcdr_1 = rsplit_1[:-1]\n    rrevcdr_2 = rrevcdr_1[:-1]\n    rappend_1 = rrevcdr_2 + ['t']\n    rappend_2 = rappend_1 + ['w']\n    return \"\".join(rappend_2)",
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_526_if_the_word_ends_with_any_letter_any_letter_replace_that_with_t_w(arg1):\n    rrevcdr_1 = arg1[:-1]\n    rrevcdr_2 = rrevcdr_1[:-1]\n    rappend_1 = rrevcdr_2 + ['t']\n    rappend_2 = rappend_1 + ['w']\n    return f6(f6_0, lambda lx: rappend_1 + ['w'], arg1)"
        },
        {
            "annotation": "if there is n replace that with g g",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _n _g _g))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_527_if_there_is_n_replace_that_with_g_g(arg1):\n    return f4(f4_0, arg1, 'n', 'g', 'g')"
        },
        {
            "annotation": "if there is i replace that with u u",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _i _u _u))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_529_if_there_is_i_replace_that_with_u_u(arg1):\n    return f4(f4_0, arg1, 'i', 'u', 'u')"
        },
        {
            "annotation": "if there is h add p after that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _h _h _p))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_530_if_there_is_h_add_p_after_that(arg1):\n    return f4(f4_0, arg1, 'h', 'h', 'p')"
        },
        {
            "annotation": "if the word ends with any letter replace that with x m",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _m _x $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_536_if_the_word_ends_with_any_letter_replace_that_with_x_m(arg1):\n    return f3(f3_0, 'm', 'x', arg1)"
        },
        {
            "annotation": "if there is any letter add x after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $0 (lambda (_rconcat $0 _x))))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef re2_train_537_if_there_is_any_letter_add_x_after_that(arg1):\n    rconcat_1 = arg1 + 'x'\n    return f8(f8_0, arg1, lambda lx: lx + 'x')"
        },
        {
            "annotation": "if the word starts with any letter replace that with m k",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _k _m)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_541_if_the_word_starts_with_any_letter_replace_that_with_m_k(arg1):\n    f5_1 = f5(f5_0, arg1, 'k', 'm')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'k', 'm'), arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with p e",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _e _p)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_542_if_the_word_starts_with_any_letter_replace_that_with_p_e(arg1):\n    f5_1 = f5(f5_0, arg1, 'e', 'p')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'e', 'p'), arg1)"
        },
        {
            "annotation": "if there is any letter replace that with g x",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _x _g))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_545_if_there_is_any_letter_replace_that_with_g_x(arg1):\n    return f0(f0_0, arg1, 'x', 'g')"
        },
        {
            "annotation": "if the word ends with s add e before that",
            "best_program": "(lambda (if (_rmatch (_rtail (_rsplit _rempty $0)) _s) (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _s _e $0) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_549_if_the_word_ends_with_s_add_e_before_that(arg1):\n    f3_1 = f3(f3_0, 's', 'e', arg1)\n    rsplit_1 = __regex_split('', arg1)\n    rtail_1 = rsplit_1[-1]\n    rmatch_1 = __ismatch(rtail_1, 's')\n    return f3_1 if rmatch_1 else arg1"
        },
        {
            "annotation": "if there is h replace that with a",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _h $0 _a))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_553_if_there_is_h_replace_that_with_a(arg1):\n    return f7(f7_0, 'h', arg1, 'a')"
        },
        {
            "annotation": "if there is p replace that with r t",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _p _r _t))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_556_if_there_is_p_replace_that_with_r_t(arg1):\n    return f4(f4_0, arg1, 'p', 'r', 't')"
        },
        {
            "annotation": "if there is n replace that with s",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _n $0 _s))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_559_if_there_is_n_replace_that_with_s(arg1):\n    return f7(f7_0, 'n', arg1, 's')"
        },
        {
            "annotation": "if the word ends with any letter replace that with y b",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _b _y $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_562_if_the_word_ends_with_any_letter_replace_that_with_y_b(arg1):\n    return f3(f3_0, 'b', 'y', arg1)"
        },
        {
            "annotation": "if there is h replace that with k s",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _h _k _s))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_566_if_there_is_h_replace_that_with_k_s(arg1):\n    return f4(f4_0, arg1, 'h', 'k', 's')"
        },
        {
            "annotation": "if the word starts with any letter add l after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _l (car (_rrevcdr $0)))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_567_if_the_word_starts_with_any_letter_add_l_after_that(arg1):\n    rrevcdr_1 = arg1[:-1]\n    car_1 = rrevcdr_1[0]\n    f5_1 = f5(f5_0, arg1, 'l', car_1)\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'l', car_1), arg1)"
        },
        {
            "annotation": "if the word starts with any letter add d before that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _d $0)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_569_if_the_word_starts_with_any_letter_add_d_before_that(arg1):\n    cons_1 = ['d'] + arg1\n    return f6(f6_0, lambda lx: ['d'] + lx, arg1)"
        },
        {
            "annotation": "if there is t replace that with k s",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _t _k _s))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_570_if_there_is_t_replace_that_with_k_s(arg1):\n    return f4(f4_0, arg1, 't', 'k', 's')"
        },
        {
            "annotation": "if the word starts with consonant replace that with f j",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _j _f)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_573_if_the_word_starts_with_consonant_replace_that_with_f_j(arg1):\n    f5_1 = f5(f5_0, arg1, 'j', 'f')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'j', 'f'), arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with j p",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _p _j)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_577_if_the_word_starts_with_any_letter_replace_that_with_j_p(arg1):\n    f5_1 = f5(f5_0, arg1, 'p', 'j')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'p', 'j'), arg1)"
        },
        {
            "annotation": "if the word starts with any letter add x before that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _x $0)) $0))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_583_if_the_word_starts_with_any_letter_add_x_before_that(arg1):\n    rsplit_1 = __regex_split('a', arg1)\n    cons_1 = ['x'] + rsplit_1\n    return \"\".join(cons_1)",
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_583_if_the_word_starts_with_any_letter_add_x_before_that(arg1):\n    cons_1 = ['x'] + arg1\n    return f6(f6_0, lambda lx: ['x'] + lx, arg1)"
        },
        {
            "annotation": "if there is any letter add r after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $0 (lambda (_rconcat $0 _r))))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef re2_train_585_if_there_is_any_letter_add_r_after_that(arg1):\n    rconcat_1 = arg1 + 'r'\n    return f8(f8_0, arg1, lambda lx: lx + 'r')"
        },
        {
            "annotation": "if the word ends with any letter consonant replace that with k t",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (if (_rmatch (_rtail $0) _e) $0 (_rappend _t (_rappend _k (_rrevcdr (_rrevcdr $0)))))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_586_if_the_word_ends_with_any_letter_consonant_replace_that_with_k_t(arg1):\n    rrevcdr_1 = arg1[:-1]\n    rrevcdr_2 = rrevcdr_1[:-1]\n    rappend_1 = rrevcdr_2 + ['k']\n    rappend_2 = rappend_1 + ['t']\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 'e')\n    if_1 = arg1 if rmatch_1 else rappend_2\n    return f6(f6_0, lambda lx: lx if rmatch_1 else rappend_2, arg1)"
        },
        {
            "annotation": "if the word starts with any letter any letter replace that with e o",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) (cdr $0) _o _e)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_590_if_the_word_starts_with_any_letter_any_letter_replace_that_with_e_o(arg1):\n    cdr_1 = arg1[1:]\n    f5_1 = f5(f5_0, cdr_1, 'o', 'e')\n    return f6(f6_0, lambda lx: f5(f5_0, cdr_1, 'o', 'e'), arg1)"
        },
        {
            "annotation": "if the word starts with any letter any letter add p before that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _p $0)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_594_if_the_word_starts_with_any_letter_any_letter_add_p_before_that(arg1):\n    cons_1 = ['p'] + arg1\n    return f6(f6_0, lambda lx: ['p'] + lx, arg1)"
        },
        {
            "annotation": "if there is n replace that with m",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _n $0 _m))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_599_if_there_is_n_replace_that_with_m(arg1):\n    return f7(f7_0, 'n', arg1, 'm')"
        },
        {
            "annotation": "if the word starts with any letter replace that with u p",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _p _u)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_603_if_the_word_starts_with_any_letter_replace_that_with_u_p(arg1):\n    f5_1 = f5(f5_0, arg1, 'p', 'u')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'p', 'u'), arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with l c",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _c _l)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_607_if_the_word_starts_with_any_letter_replace_that_with_l_c(arg1):\n    f5_1 = f5(f5_0, arg1, 'c', 'l')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'c', 'l'), arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with i e",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _e _i)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_608_if_the_word_starts_with_any_letter_replace_that_with_i_e(arg1):\n    f5_1 = f5(f5_0, arg1, 'e', 'i')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'e', 'i'), arg1)"
        },
        {
            "annotation": "if the word starts with any letter any letter replace that with r n",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) (cdr $0) _n _r)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_609_if_the_word_starts_with_any_letter_any_letter_replace_that_with_r_n(arg1):\n    cdr_1 = arg1[1:]\n    f5_1 = f5(f5_0, cdr_1, 'n', 'r')\n    return f6(f6_0, lambda lx: f5(f5_0, cdr_1, 'n', 'r'), arg1)"
        },
        {
            "annotation": "if there is any letter i add e after that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _i _i _e))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_611_if_there_is_any_letter_i_add_e_after_that(arg1):\n    return f4(f4_0, arg1, 'i', 'i', 'e')"
        },
        {
            "annotation": "if there is i replace that with k",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _i $0 _k))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_615_if_there_is_i_replace_that_with_k(arg1):\n    return f7(f7_0, 'i', arg1, 'k')"
        },
        {
            "annotation": "if the word ends with any letter replace that with d k",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _k _d $0))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_620_if_the_word_ends_with_any_letter_replace_that_with_d_k(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    rrevcdr_1 = rsplit_1[:-1]\n    rappend_1 = rrevcdr_1 + ['d']\n    rappend_2 = rappend_1 + ['k']\n    return \"\".join(rappend_2)",
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_620_if_the_word_ends_with_any_letter_replace_that_with_d_k(arg1):\n    return f3(f3_0, 'k', 'd', arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with v q",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _q _v)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_625_if_the_word_starts_with_any_letter_replace_that_with_v_q(arg1):\n    f5_1 = f5(f5_0, arg1, 'q', 'v')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'q', 'v'), arg1)"
        },
        {
            "annotation": "if the word ends with s replace that with p",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (if (_rmatch (_rtail $0) _s) (_rappend _p (_rrevcdr $0)) $0)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_627_if_the_word_ends_with_s_replace_that_with_p(arg1):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + ['p']\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 's')\n    if_1 = rappend_1 if rmatch_1 else arg1\n    return f6(f6_0, lambda lx: rappend_1 if rmatch_1 else lx, arg1)"
        },
        {
            "annotation": "if the word ends with consonant replace that with q w",
            "best_program": "(lambda (#(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend (if (_rmatch (_rtail $0) _e) _e $1) (_rrevcdr $0))))) (_rconcat _q _w) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f2(arg1, arg2):\n    rrevcdr_1 = arg1[:-1]\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 'e')\n    if_1 = 'e' if rmatch_1 else arg2\n    rappend_1 = rrevcdr_1 + [if_1]\n    return f6(f6_0, lambda lx: rrevcdr_1 + [if_1])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_628_if_the_word_ends_with_consonant_replace_that_with_q_w(arg1):\n    rconcat_1 = 'q' + 'w'\n    return f2(f2_0, rconcat_1, arg1)"
        },
        {
            "annotation": "if there is o replace that with j",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _o $0 _j))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_630_if_there_is_o_replace_that_with_j(arg1):\n    return f7(f7_0, 'o', arg1, 'j')"
        },
        {
            "annotation": "if the word starts with consonant any letter add c before that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _e $0 $0 (cons _c $0))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f1(arg1, arg2, arg3, arg4):\n    rrevcdr_1 = arg1[:-1]\n    car_1 = rrevcdr_1[0]\n    rmatch_1 = __ismatch(car_1, arg2)\n    return arg1 if rmatch_1 else arg2\n\ndef re2_train_632_if_the_word_starts_with_consonant_any_letter_add_c_before_that(arg1):\n    cons_1 = ['c'] + arg1\n    f1_1 = f1(f1_0, 'e', arg1, arg1, cons_1)\n    return f6(f6_0, lambda lx: f1(f1_0, 'e', lx, lx, cons_1), arg1)"
        },
        {
            "annotation": "if the word starts with any letter add t before that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _t $0)) $0))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_640_if_the_word_starts_with_any_letter_add_t_before_that(arg1):\n    rsplit_1 = __regex_split('a', arg1)\n    cons_1 = ['t'] + rsplit_1\n    return \"\".join(cons_1)",
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_640_if_the_word_starts_with_any_letter_add_t_before_that(arg1):\n    cons_1 = ['t'] + arg1\n    return f6(f6_0, lambda lx: ['t'] + lx, arg1)"
        },
        {
            "annotation": "if the word ends with consonant replace that with u a",
            "best_program": "(lambda (#(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend (if (_rmatch (_rtail $0) _e) _e $1) (_rrevcdr $0))))) (_rconcat _u _a) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f2(arg1, arg2):\n    rrevcdr_1 = arg1[:-1]\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 'e')\n    if_1 = 'e' if rmatch_1 else arg2\n    rappend_1 = rrevcdr_1 + [if_1]\n    return f6(f6_0, lambda lx: rrevcdr_1 + [if_1])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_641_if_the_word_ends_with_consonant_replace_that_with_u_a(arg1):\n    rconcat_1 = 'u' + 'a'\n    return f2(f2_0, rconcat_1, arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with b a",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _a _b)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_644_if_the_word_starts_with_any_letter_replace_that_with_b_a(arg1):\n    f5_1 = f5(f5_0, arg1, 'a', 'b')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'a', 'b'), arg1)"
        },
        {
            "annotation": "if the word ends with any letter replace that with l n",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _n _l $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_650_if_the_word_ends_with_any_letter_replace_that_with_l_n(arg1):\n    return f3(f3_0, 'n', 'l', arg1)"
        },
        {
            "annotation": "if there is a replace that with v",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _a $0 _v))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_653_if_there_is_a_replace_that_with_v(arg1):\n    return f7(f7_0, 'a', arg1, 'v')"
        },
        {
            "annotation": "if there is p replace that with e",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _p $0 _e))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_659_if_there_is_p_replace_that_with_e(arg1):\n    return f7(f7_0, 'p', arg1, 'e')"
        },
        {
            "annotation": "if there is any letter add c before that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $0 (lambda (_rconcat _c $0))))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef re2_train_661_if_there_is_any_letter_add_c_before_that(arg1):\n    rconcat_1 = 'c' + arg1\n    return f8(f8_0, arg1, lambda lx: 'c' + lx)"
        },
        {
            "annotation": "if there is s replace that with v",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _s $0 _v))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_662_if_there_is_s_replace_that_with_v(arg1):\n    return f7(f7_0, 's', arg1, 'v')"
        },
        {
            "annotation": "if the word ends with consonant replace that with n",
            "best_program": "(lambda (#(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend (if (_rmatch (_rtail $0) _e) _e $1) (_rrevcdr $0))))) _n $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f2(arg1, arg2):\n    rrevcdr_1 = arg1[:-1]\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 'e')\n    if_1 = 'e' if rmatch_1 else arg2\n    rappend_1 = rrevcdr_1 + [if_1]\n    return f6(f6_0, lambda lx: rrevcdr_1 + [if_1])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_664_if_the_word_ends_with_consonant_replace_that_with_n(arg1):\n    return f2(f2_0, 'n', arg1)"
        },
        {
            "annotation": "if there is g replace that with i l",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _g _i _l))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_668_if_there_is_g_replace_that_with_i_l(arg1):\n    return f4(f4_0, arg1, 'g', 'i', 'l')"
        },
        {
            "annotation": "if there is any letter replace that with j h",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _h _j))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_670_if_there_is_any_letter_replace_that_with_j_h(arg1):\n    return f0(f0_0, arg1, 'h', 'j')"
        },
        {
            "annotation": "if the word ends with any letter replace that with m y",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _y _m $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_673_if_the_word_ends_with_any_letter_replace_that_with_m_y(arg1):\n    return f3(f3_0, 'y', 'm', arg1)"
        },
        {
            "annotation": "if there is any letter replace that with x o",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _o _x))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_674_if_there_is_any_letter_replace_that_with_x_o(arg1):\n    return f0(f0_0, arg1, 'o', 'x')"
        },
        {
            "annotation": "if there is any letter add k before that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $0 (lambda (_rconcat _k $0))))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef re2_train_676_if_there_is_any_letter_add_k_before_that(arg1):\n    rconcat_1 = 'k' + arg1\n    return f8(f8_0, arg1, lambda lx: 'k' + lx)"
        },
        {
            "annotation": "if there is any letter replace that with n w",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _w _n))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_677_if_there_is_any_letter_replace_that_with_n_w(arg1):\n    return f0(f0_0, arg1, 'w', 'n')"
        },
        {
            "annotation": "if the word starts with any letter replace that with q",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _q (cdr $0))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_679_if_the_word_starts_with_any_letter_replace_that_with_q(arg1):\n    cdr_1 = arg1[1:]\n    cons_1 = ['q'] + cdr_1\n    return f6(f6_0, lambda lx: ['q'] + cdr_1, arg1)"
        },
        {
            "annotation": "if there is any letter replace that with x j",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _j _x))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_683_if_there_is_any_letter_replace_that_with_x_j(arg1):\n    return f0(f0_0, arg1, 'j', 'x')"
        },
        {
            "annotation": "if there is g replace that with n",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _g $0 _n))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_686_if_there_is_g_replace_that_with_n(arg1):\n    return f7(f7_0, 'g', arg1, 'n')"
        },
        {
            "annotation": "if there is a double that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _a _a _a))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_690_if_there_is_a_double_that(arg1):\n    return f4(f4_0, arg1, 'a', 'a', 'a')"
        },
        {
            "annotation": "if the word ends with s add m before that",
            "best_program": "(lambda (if (_rmatch (_rtail (_rsplit _rempty $0)) _s) (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _s _m $0) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_691_if_the_word_ends_with_s_add_m_before_that(arg1):\n    f3_1 = f3(f3_0, 's', 'm', arg1)\n    rsplit_1 = __regex_split('', arg1)\n    rtail_1 = rsplit_1[-1]\n    rmatch_1 = __ismatch(rtail_1, 's')\n    return f3_1 if rmatch_1 else arg1"
        },
        {
            "annotation": "if the word starts with consonant add d after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _e $0 _rempty _d) (car (_rrevcdr $0)))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f1(arg1, arg2, arg3, arg4):\n    rrevcdr_1 = arg1[:-1]\n    car_1 = rrevcdr_1[0]\n    rmatch_1 = __ismatch(car_1, arg2)\n    return arg1 if rmatch_1 else arg2\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_694_if_the_word_starts_with_consonant_add_d_after_that(arg1):\n    rrevcdr_1 = arg1[:-1]\n    car_1 = rrevcdr_1[0]\n    f1_1 = f1(f1_0, 'e', arg1, '', 'd')\n    f5_1 = f5(f5_0, arg1, f1_1, car_1)\n    return f6(f6_0, lambda lx: f5(f5_0, lx, f1_1, car_1), arg1)"
        },
        {
            "annotation": "if there is s add x before that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _s _x _s))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_700_if_there_is_s_add_x_before_that(arg1):\n    return f4(f4_0, arg1, 's', 'x', 's')"
        },
        {
            "annotation": "if the word starts with consonant replace that with t d",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _e $0 $0 (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _d _t))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f1(arg1, arg2, arg3, arg4):\n    rrevcdr_1 = arg1[:-1]\n    car_1 = rrevcdr_1[0]\n    rmatch_1 = __ismatch(car_1, arg2)\n    return arg1 if rmatch_1 else arg2\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_703_if_the_word_starts_with_consonant_replace_that_with_t_d(arg1):\n    f5_1 = f5(f5_0, arg1, 'd', 't')\n    f1_1 = f1(f1_0, 'e', arg1, arg1, f5_1)\n    return f6(f6_0, lambda lx: f1(f1_0, 'e', lx, lx, f5_1), arg1)"
        },
        {
            "annotation": "if the word ends with any letter replace that with b",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _b _rempty $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_705_if_the_word_ends_with_any_letter_replace_that_with_b(arg1):\n    return f3(f3_0, 'b', '', arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with g t",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _t _g)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_706_if_the_word_starts_with_any_letter_replace_that_with_g_t(arg1):\n    f5_1 = f5(f5_0, arg1, 't', 'g')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 't', 'g'), arg1)"
        },
        {
            "annotation": "if there is s replace that with q",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _s $0 _q))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_709_if_there_is_s_replace_that_with_q(arg1):\n    return f7(f7_0, 's', arg1, 'q')"
        },
        {
            "annotation": "if the word starts with any letter replace that with p n",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _n _p)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_711_if_the_word_starts_with_any_letter_replace_that_with_p_n(arg1):\n    f5_1 = f5(f5_0, arg1, 'n', 'p')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'n', 'p'), arg1)"
        },
        {
            "annotation": "if there is t replace that with c y",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _t _c _y))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_713_if_there_is_t_replace_that_with_c_y(arg1):\n    return f4(f4_0, arg1, 't', 'c', 'y')"
        },
        {
            "annotation": "if there is m add l before that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _m _l _m))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_716_if_there_is_m_add_l_before_that(arg1):\n    return f4(f4_0, arg1, 'm', 'l', 'm')"
        },
        {
            "annotation": "if the word starts with any letter replace that with b k",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _k _b)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_718_if_the_word_starts_with_any_letter_replace_that_with_b_k(arg1):\n    f5_1 = f5(f5_0, arg1, 'k', 'b')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'k', 'b'), arg1)"
        },
        {
            "annotation": "if there is e replace that with u",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _e $0 _u))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_721_if_there_is_e_replace_that_with_u(arg1):\n    return f7(f7_0, 'e', arg1, 'u')"
        },
        {
            "annotation": "if the word starts with any letter replace that with j w",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _w _j)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_722_if_the_word_starts_with_any_letter_replace_that_with_j_w(arg1):\n    f5_1 = f5(f5_0, arg1, 'w', 'j')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'w', 'j'), arg1)"
        },
        {
            "annotation": "if there is any letter replace that with j f",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _f _j))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_724_if_there_is_any_letter_replace_that_with_j_f(arg1):\n    return f0(f0_0, arg1, 'f', 'j')"
        },
        {
            "annotation": "if there is any letter replace that with i v",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _v _i))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_726_if_there_is_any_letter_replace_that_with_i_v(arg1):\n    return f0(f0_0, arg1, 'v', 'i')"
        },
        {
            "annotation": "if the word starts with any letter any letter replace that with k",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _k (cdr (cdr $0)))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_727_if_the_word_starts_with_any_letter_any_letter_replace_that_with_k(arg1):\n    cdr_1 = arg1[1:]\n    cdr_2 = cdr_1[1:]\n    cons_1 = ['k'] + cdr_2\n    return f6(f6_0, lambda lx: ['k'] + cdr_2, arg1)"
        },
        {
            "annotation": "if the word ends with consonant replace that with m a",
            "best_program": "(lambda (#(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend (if (_rmatch (_rtail $0) _e) _e $1) (_rrevcdr $0))))) (_rconcat _m _a) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f2(arg1, arg2):\n    rrevcdr_1 = arg1[:-1]\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 'e')\n    if_1 = 'e' if rmatch_1 else arg2\n    rappend_1 = rrevcdr_1 + [if_1]\n    return f6(f6_0, lambda lx: rrevcdr_1 + [if_1])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_731_if_the_word_ends_with_consonant_replace_that_with_m_a(arg1):\n    rconcat_1 = 'm' + 'a'\n    return f2(f2_0, rconcat_1, arg1)"
        },
        {
            "annotation": "if there is t add d before that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _t _d _t))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_734_if_there_is_t_add_d_before_that(arg1):\n    return f4(f4_0, arg1, 't', 'd', 't')"
        },
        {
            "annotation": "if there is any letter add y after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $0 (lambda (_rconcat $0 _y))))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef re2_train_737_if_there_is_any_letter_add_y_after_that(arg1):\n    rconcat_1 = arg1 + 'y'\n    return f8(f8_0, arg1, lambda lx: lx + 'y')"
        },
        {
            "annotation": "if the word starts with any letter replace that with s n",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _n _s)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_739_if_the_word_starts_with_any_letter_replace_that_with_s_n(arg1):\n    f5_1 = f5(f5_0, arg1, 'n', 's')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'n', 's'), arg1)"
        },
        {
            "annotation": "if the word ends with any letter any letter replace that with k",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend _k (_rrevcdr (_rrevcdr $0)))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_743_if_the_word_ends_with_any_letter_any_letter_replace_that_with_k(arg1):\n    rrevcdr_1 = arg1[:-1]\n    rrevcdr_2 = rrevcdr_1[:-1]\n    rappend_1 = rrevcdr_2 + ['k']\n    return f6(f6_0, lambda lx: rrevcdr_2 + ['k'], arg1)"
        },
        {
            "annotation": "if there is p replace that with a",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _p $0 _a))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_750_if_there_is_p_replace_that_with_a(arg1):\n    return f7(f7_0, 'p', arg1, 'a')"
        },
        {
            "annotation": "if the word starts with any letter any letter replace that with h t",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) (cdr $0) _t _h)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_753_if_the_word_starts_with_any_letter_any_letter_replace_that_with_h_t(arg1):\n    cdr_1 = arg1[1:]\n    f5_1 = f5(f5_0, cdr_1, 't', 'h')\n    return f6(f6_0, lambda lx: f5(f5_0, cdr_1, 't', 'h'), arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with n g",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _g _n)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_755_if_the_word_starts_with_any_letter_replace_that_with_n_g(arg1):\n    f5_1 = f5(f5_0, arg1, 'g', 'n')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'g', 'n'), arg1)"
        },
        {
            "annotation": "if the word starts with consonant replace that with m y",
            "best_program": "(lambda (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _n (cdr (_rsplit _rempty $0)) $0 (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _y _m)) $0)))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f1(arg1, arg2, arg3, arg4):\n    rrevcdr_1 = arg1[:-1]\n    car_1 = rrevcdr_1[0]\n    rmatch_1 = __ismatch(car_1, arg2)\n    return arg1 if rmatch_1 else arg2\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_756_if_the_word_starts_with_consonant_replace_that_with_m_y(arg1):\n    f5_1 = f5(f5_0, arg1, 'y', 'm')\n    f6_1 = f6(f6_0, lambda lx: f5(f5_0, lx, 'y', 'm'), arg1)\n    rsplit_1 = __regex_split('', arg1)\n    cdr_1 = rsplit_1[1:]\n    return f1(f1_0, 'n', cdr_1, arg1, f6_1)"
        },
        {
            "annotation": "if there is l replace that with n",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _l $0 _n))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_759_if_there_is_l_replace_that_with_n(arg1):\n    return f7(f7_0, 'l', arg1, 'n')"
        },
        {
            "annotation": "if there is any letter add h after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $0 (lambda (_rconcat $0 _h))))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef re2_train_760_if_there_is_any_letter_add_h_after_that(arg1):\n    rconcat_1 = arg1 + 'h'\n    return f8(f8_0, arg1, lambda lx: lx + 'h')"
        },
        {
            "annotation": "if the word ends with any letter add f before that",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) (_rtail (_rsplit _rempty $0)) _f $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_763_if_the_word_ends_with_any_letter_add_f_before_that(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    rtail_1 = rsplit_1[-1]\n    return f3(f3_0, rtail_1, 'f', arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with b n",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _n _b)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_764_if_the_word_starts_with_any_letter_replace_that_with_b_n(arg1):\n    f5_1 = f5(f5_0, arg1, 'n', 'b')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'n', 'b'), arg1)"
        },
        {
            "annotation": "if the word ends with consonant replace that with q x",
            "best_program": "(lambda (#(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend (if (_rmatch (_rtail $0) _e) _e $1) (_rrevcdr $0))))) (_rconcat _q _x) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f2(arg1, arg2):\n    rrevcdr_1 = arg1[:-1]\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 'e')\n    if_1 = 'e' if rmatch_1 else arg2\n    rappend_1 = rrevcdr_1 + [if_1]\n    return f6(f6_0, lambda lx: rrevcdr_1 + [if_1])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_768_if_the_word_ends_with_consonant_replace_that_with_q_x(arg1):\n    rconcat_1 = 'q' + 'x'\n    return f2(f2_0, rconcat_1, arg1)"
        },
        {
            "annotation": "if the word starts with consonant replace that with r",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _a $0 $0 (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _rempty _r))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f1(arg1, arg2, arg3, arg4):\n    rrevcdr_1 = arg1[:-1]\n    car_1 = rrevcdr_1[0]\n    rmatch_1 = __ismatch(car_1, arg2)\n    return arg1 if rmatch_1 else arg2\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_771_if_the_word_starts_with_consonant_replace_that_with_r(arg1):\n    f5_1 = f5(f5_0, arg1, '', 'r')\n    f1_1 = f1(f1_0, 'a', arg1, arg1, f5_1)\n    return f6(f6_0, lambda lx: f1(f1_0, 'a', lx, lx, f5_1), arg1)"
        },
        {
            "annotation": "if there is e replace that with e h",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _e _e _h))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_772_if_there_is_e_replace_that_with_e_h(arg1):\n    return f4(f4_0, arg1, 'e', 'e', 'h')"
        },
        {
            "annotation": "if there is any letter replace that with f m",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _m _f))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_774_if_there_is_any_letter_replace_that_with_f_m(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    rconcat_1 = 'f' + 'm'\n    map_1 = list(map(lambda lx: rconcat_1, rsplit_1))\n    return \"\".join(map_1)",
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_774_if_there_is_any_letter_replace_that_with_f_m(arg1):\n    return f0(f0_0, arg1, 'm', 'f')"
        },
        {
            "annotation": "if the word starts with any letter any letter replace that with r c",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) (cdr $0) _c _r)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_779_if_the_word_starts_with_any_letter_any_letter_replace_that_with_r_c(arg1):\n    cdr_1 = arg1[1:]\n    f5_1 = f5(f5_0, cdr_1, 'c', 'r')\n    return f6(f6_0, lambda lx: f5(f5_0, cdr_1, 'c', 'r'), arg1)"
        },
        {
            "annotation": "if there is s replace that with m s",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _s _m _s))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_780_if_there_is_s_replace_that_with_m_s(arg1):\n    return f4(f4_0, arg1, 's', 'm', 's')"
        },
        {
            "annotation": "if the word starts with consonant replace that with f n",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _e $0 $0 (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _i $0 $0 (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _n _f)))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f1(arg1, arg2, arg3, arg4):\n    rrevcdr_1 = arg1[:-1]\n    car_1 = rrevcdr_1[0]\n    rmatch_1 = __ismatch(car_1, arg2)\n    return arg1 if rmatch_1 else arg2\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_784_if_the_word_starts_with_consonant_replace_that_with_f_n(arg1):\n    f5_1 = f5(f5_0, arg1, 'n', 'f')\n    f1_1 = f1(f1_0, 'i', arg1, arg1, f5_1)\n    f1_2 = f1(f1_1, 'e', arg1, arg1, f1_1)\n    return f6(f6_0, lambda lx: f1(f1_1, 'e', lx, lx, f1_1), arg1)"
        },
        {
            "annotation": "if the word starts with any letter any letter replace that with l",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _l (cdr (cdr $0)))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_786_if_the_word_starts_with_any_letter_any_letter_replace_that_with_l(arg1):\n    cdr_1 = arg1[1:]\n    cdr_2 = cdr_1[1:]\n    cons_1 = ['l'] + cdr_2\n    return f6(f6_0, lambda lx: ['l'] + cdr_2, arg1)"
        },
        {
            "annotation": "if the word starts with consonant e replace that with s",
            "best_program": "(lambda (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _e (cdr (_rsplit _rempty $0)) (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) (cdr $0) _rempty _s)) $0) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f1(arg1, arg2, arg3, arg4):\n    rrevcdr_1 = arg1[:-1]\n    car_1 = rrevcdr_1[0]\n    rmatch_1 = __ismatch(car_1, arg2)\n    return arg1 if rmatch_1 else arg2\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_790_if_the_word_starts_with_consonant_e_replace_that_with_s(arg1):\n    cdr_1 = arg1[1:]\n    f5_1 = f5(f5_0, cdr_1, '', 's')\n    f6_1 = f6(f6_0, lambda lx: f5(f5_0, cdr_1, '', 's'), arg1)\n    rsplit_1 = __regex_split('', arg1)\n    cdr_2 = rsplit_1[1:]\n    return f1(f1_0, 'e', cdr_2, f6_1, arg1)"
        },
        {
            "annotation": "if there is any letter replace that with h g",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _g _h))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_791_if_there_is_any_letter_replace_that_with_h_g(arg1):\n    return f0(f0_0, arg1, 'g', 'h')"
        },
        {
            "annotation": "if the word ends with any letter any letter replace that with j a",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend _a (_rappend _j (_rrevcdr (_rrevcdr $0))))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_796_if_the_word_ends_with_any_letter_any_letter_replace_that_with_j_a(arg1):\n    rrevcdr_1 = arg1[:-1]\n    rrevcdr_2 = rrevcdr_1[:-1]\n    rappend_1 = rrevcdr_2 + ['j']\n    rappend_2 = rappend_1 + ['a']\n    return f6(f6_0, lambda lx: rappend_1 + ['a'], arg1)"
        },
        {
            "annotation": "if the word ends with any letter replace that with e y",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _y _e $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_797_if_the_word_ends_with_any_letter_replace_that_with_e_y(arg1):\n    return f3(f3_0, 'y', 'e', arg1)"
        },
        {
            "annotation": "if the word ends with consonant replace that with j",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _a $0 _e _j) (_rrevcdr $0))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f1(arg1, arg2, arg3, arg4):\n    rrevcdr_1 = arg1[:-1]\n    car_1 = rrevcdr_1[0]\n    rmatch_1 = __ismatch(car_1, arg2)\n    return arg1 if rmatch_1 else arg2\n\ndef re2_train_811_if_the_word_ends_with_consonant_replace_that_with_j(arg1):\n    rrevcdr_1 = arg1[:-1]\n    f1_1 = f1(f1_0, 'a', arg1, 'e', 'j')\n    rappend_1 = rrevcdr_1 + [f1_1]\n    return f6(f6_0, lambda lx: rrevcdr_1 + [f1_1], arg1)"
        },
        {
            "annotation": "if there is any letter replace that with u y",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _y _u))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_812_if_there_is_any_letter_replace_that_with_u_y(arg1):\n    return f0(f0_0, arg1, 'y', 'u')"
        },
        {
            "annotation": "if there is o replace that with b",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _o $0 _b))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_817_if_there_is_o_replace_that_with_b(arg1):\n    return f7(f7_0, 'o', arg1, 'b')"
        },
        {
            "annotation": "if the word ends with consonant replace that with m p",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _p _m $0))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_821_if_the_word_ends_with_consonant_replace_that_with_m_p(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    rrevcdr_1 = rsplit_1[:-1]\n    rappend_1 = rrevcdr_1 + ['m']\n    rappend_2 = rappend_1 + ['p']\n    return \"\".join(rappend_2)",
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_821_if_the_word_ends_with_consonant_replace_that_with_m_p(arg1):\n    return f3(f3_0, 'p', 'm', arg1)"
        },
        {
            "annotation": "if the word starts with consonant replace that with b i",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _a $0 $0 (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _i _b))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f1(arg1, arg2, arg3, arg4):\n    rrevcdr_1 = arg1[:-1]\n    car_1 = rrevcdr_1[0]\n    rmatch_1 = __ismatch(car_1, arg2)\n    return arg1 if rmatch_1 else arg2\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_823_if_the_word_starts_with_consonant_replace_that_with_b_i(arg1):\n    f5_1 = f5(f5_0, arg1, 'i', 'b')\n    f1_1 = f1(f1_0, 'a', arg1, arg1, f5_1)\n    return f6(f6_0, lambda lx: f1(f1_0, 'a', lx, lx, f5_1), arg1)"
        },
        {
            "annotation": "if there is s replace that with w",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _s $0 _w))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_826_if_there_is_s_replace_that_with_w(arg1):\n    return f7(f7_0, 's', arg1, 'w')"
        },
        {
            "annotation": "if there is p add m after that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _p _p _m))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_828_if_there_is_p_add_m_after_that(arg1):\n    return f4(f4_0, arg1, 'p', 'p', 'm')"
        },
        {
            "annotation": "if the word ends with any letter replace that with v j",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _j _v $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_831_if_the_word_ends_with_any_letter_replace_that_with_v_j(arg1):\n    return f3(f3_0, 'j', 'v', arg1)"
        },
        {
            "annotation": "if the word starts with consonant replace that with l a",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _u $0 $0 (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _a _l))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f1(arg1, arg2, arg3, arg4):\n    rrevcdr_1 = arg1[:-1]\n    car_1 = rrevcdr_1[0]\n    rmatch_1 = __ismatch(car_1, arg2)\n    return arg1 if rmatch_1 else arg2\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_834_if_the_word_starts_with_consonant_replace_that_with_l_a(arg1):\n    f5_1 = f5(f5_0, arg1, 'a', 'l')\n    f1_1 = f1(f1_0, 'u', arg1, arg1, f5_1)\n    return f6(f6_0, lambda lx: f1(f1_0, 'u', lx, lx, f5_1), arg1)"
        },
        {
            "annotation": "if there is m add a before that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _m _a _m))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_837_if_there_is_m_add_a_before_that(arg1):\n    return f4(f4_0, arg1, 'm', 'a', 'm')"
        },
        {
            "annotation": "if the word ends with consonant replace that with m x",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _x _m $0))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_845_if_the_word_ends_with_consonant_replace_that_with_m_x(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    rrevcdr_1 = rsplit_1[:-1]\n    rappend_1 = rrevcdr_1 + ['m']\n    rappend_2 = rappend_1 + ['x']\n    return \"\".join(rappend_2)",
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_845_if_the_word_ends_with_consonant_replace_that_with_m_x(arg1):\n    return f3(f3_0, 'x', 'm', arg1)"
        },
        {
            "annotation": "if the word starts with consonant replace that with h",
            "best_program": "(lambda (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _n (cdr (_rsplit _rempty $0)) $0 (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _rempty _h)) $0)))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f1(arg1, arg2, arg3, arg4):\n    rrevcdr_1 = arg1[:-1]\n    car_1 = rrevcdr_1[0]\n    rmatch_1 = __ismatch(car_1, arg2)\n    return arg1 if rmatch_1 else arg2\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_848_if_the_word_starts_with_consonant_replace_that_with_h(arg1):\n    f5_1 = f5(f5_0, arg1, '', 'h')\n    f6_1 = f6(f6_0, lambda lx: f5(f5_0, lx, '', 'h'), arg1)\n    rsplit_1 = __regex_split('', arg1)\n    cdr_1 = rsplit_1[1:]\n    return f1(f1_0, 'n', cdr_1, arg1, f6_1)"
        },
        {
            "annotation": "if there is any letter replace that with u t",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _t _u))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_851_if_there_is_any_letter_replace_that_with_u_t(arg1):\n    return f0(f0_0, arg1, 't', 'u')"
        },
        {
            "annotation": "if the word ends with any letter replace that with y w",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _w _y $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_857_if_the_word_ends_with_any_letter_replace_that_with_y_w(arg1):\n    return f3(f3_0, 'w', 'y', arg1)"
        },
        {
            "annotation": "if there is i replace that with e q",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _i _e _q))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_859_if_there_is_i_replace_that_with_e_q(arg1):\n    return f4(f4_0, arg1, 'i', 'e', 'q')"
        },
        {
            "annotation": "if there is any letter replace that with x a",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _a _x))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_860_if_there_is_any_letter_replace_that_with_x_a(arg1):\n    return f0(f0_0, arg1, 'a', 'x')"
        },
        {
            "annotation": "if the word starts with any letter add i after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _i (car $0))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_862_if_the_word_starts_with_any_letter_add_i_after_that(arg1):\n    car_1 = arg1[0]\n    f5_1 = f5(f5_0, arg1, 'i', car_1)\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'i', car_1), arg1)"
        },
        {
            "annotation": "if there is e add t after that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _e _e _t))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_863_if_there_is_e_add_t_after_that(arg1):\n    return f4(f4_0, arg1, 'e', 'e', 't')"
        },
        {
            "annotation": "if there is r replace that with l",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _r $0 _l))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_864_if_there_is_r_replace_that_with_l(arg1):\n    return f7(f7_0, 'r', arg1, 'l')"
        },
        {
            "annotation": "if the word starts with any letter add c before that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _c $0)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_865_if_the_word_starts_with_any_letter_add_c_before_that(arg1):\n    cons_1 = ['c'] + arg1\n    return f6(f6_0, lambda lx: ['c'] + lx, arg1)"
        },
        {
            "annotation": "if there is p replace that with y",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _p $0 _y))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_866_if_there_is_p_replace_that_with_y(arg1):\n    return f7(f7_0, 'p', arg1, 'y')"
        },
        {
            "annotation": "if the word starts with consonant replace that with c w",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _a $0 $0 (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _w _c))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f1(arg1, arg2, arg3, arg4):\n    rrevcdr_1 = arg1[:-1]\n    car_1 = rrevcdr_1[0]\n    rmatch_1 = __ismatch(car_1, arg2)\n    return arg1 if rmatch_1 else arg2\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_871_if_the_word_starts_with_consonant_replace_that_with_c_w(arg1):\n    f5_1 = f5(f5_0, arg1, 'w', 'c')\n    f1_1 = f1(f1_0, 'a', arg1, arg1, f5_1)\n    return f6(f6_0, lambda lx: f1(f1_0, 'a', lx, lx, f5_1), arg1)"
        },
        {
            "annotation": "if there is any letter add e before that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $0 (lambda (_rconcat _e $0))))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef re2_train_874_if_there_is_any_letter_add_e_before_that(arg1):\n    rconcat_1 = 'e' + arg1\n    return f8(f8_0, arg1, lambda lx: 'e' + lx)"
        },
        {
            "annotation": "if the word ends with any letter replace that with w w",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _w _w $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_875_if_the_word_ends_with_any_letter_replace_that_with_w_w(arg1):\n    return f3(f3_0, 'w', 'w', arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with n u",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _u _n)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_877_if_the_word_starts_with_any_letter_replace_that_with_n_u(arg1):\n    f5_1 = f5(f5_0, arg1, 'u', 'n')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'u', 'n'), arg1)"
        },
        {
            "annotation": "if there is i add k after that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _i _i _k))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_882_if_there_is_i_add_k_after_that(arg1):\n    return f4(f4_0, arg1, 'i', 'i', 'k')"
        },
        {
            "annotation": "if the word starts with any letter any letter replace that with m h",
            "best_program": "(lambda (_rflatten (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) (cdr (_rsplit _rempty $0)) _h _m)))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_884_if_the_word_starts_with_any_letter_any_letter_replace_that_with_m_h(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    cdr_1 = rsplit_1[1:]\n    cdr_2 = cdr_1[1:]\n    rconcat_1 = 'm' + 'h'\n    cons_1 = [rconcat_1] + cdr_2\n    return \"\".join(cons_1)",
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef re2_train_884_if_the_word_starts_with_any_letter_any_letter_replace_that_with_m_h(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    cdr_1 = rsplit_1[1:]\n    f5_1 = f5(f5_0, cdr_1, 'h', 'm')\n    return \"\".join(f5_1)"
        },
        {
            "annotation": "if the word starts with any letter any letter replace that with e u",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) (cdr $0) _u _e)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_885_if_the_word_starts_with_any_letter_any_letter_replace_that_with_e_u(arg1):\n    cdr_1 = arg1[1:]\n    f5_1 = f5(f5_0, cdr_1, 'u', 'e')\n    return f6(f6_0, lambda lx: f5(f5_0, cdr_1, 'u', 'e'), arg1)"
        },
        {
            "annotation": "if the word ends with any letter replace that with i o",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _o _i $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_888_if_the_word_ends_with_any_letter_replace_that_with_i_o(arg1):\n    return f3(f3_0, 'o', 'i', arg1)"
        },
        {
            "annotation": "if there is r replace that with x",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _r $0 _x))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_889_if_there_is_r_replace_that_with_x(arg1):\n    return f7(f7_0, 'r', arg1, 'x')"
        },
        {
            "annotation": "if there is n replace that with b q",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _n _b _q))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_890_if_there_is_n_replace_that_with_b_q(arg1):\n    return f4(f4_0, arg1, 'n', 'b', 'q')"
        },
        {
            "annotation": "if there is u replace that with i",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _u $0 _i))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_897_if_there_is_u_replace_that_with_i(arg1):\n    return f7(f7_0, 'u', arg1, 'i')"
        },
        {
            "annotation": "if there is o replace that with i o",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _o _i _o))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_898_if_there_is_o_replace_that_with_i_o(arg1):\n    return f4(f4_0, arg1, 'o', 'i', 'o')"
        },
        {
            "annotation": "if the word ends with any letter replace that with c y",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _y _c $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_900_if_the_word_ends_with_any_letter_replace_that_with_c_y(arg1):\n    return f3(f3_0, 'y', 'c', arg1)"
        },
        {
            "annotation": "if the word starts with any letter add e after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _e (car $0))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_903_if_the_word_starts_with_any_letter_add_e_after_that(arg1):\n    car_1 = arg1[0]\n    f5_1 = f5(f5_0, arg1, 'e', car_1)\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'e', car_1), arg1)"
        },
        {
            "annotation": "if there is i replace that with v h",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _i _v _h))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_907_if_there_is_i_replace_that_with_v_h(arg1):\n    return f4(f4_0, arg1, 'i', 'v', 'h')"
        },
        {
            "annotation": "if the word starts with consonant add p before that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _p $0)) $0))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_908_if_the_word_starts_with_consonant_add_p_before_that(arg1):\n    rsplit_1 = __regex_split('a', arg1)\n    cons_1 = ['p'] + rsplit_1\n    return \"\".join(cons_1)",
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_908_if_the_word_starts_with_consonant_add_p_before_that(arg1):\n    cons_1 = ['p'] + arg1\n    return f6(f6_0, lambda lx: ['p'] + lx, arg1)"
        },
        {
            "annotation": "if there is g add a after that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _g _g _a))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_920_if_there_is_g_add_a_after_that(arg1):\n    return f4(f4_0, arg1, 'g', 'g', 'a')"
        },
        {
            "annotation": "if the word ends with any letter replace that with c d",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _d _c $0))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_922_if_the_word_ends_with_any_letter_replace_that_with_c_d(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    rrevcdr_1 = rsplit_1[:-1]\n    rappend_1 = rrevcdr_1 + ['c']\n    rappend_2 = rappend_1 + ['d']\n    return \"\".join(rappend_2)",
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_922_if_the_word_ends_with_any_letter_replace_that_with_c_d(arg1):\n    return f3(f3_0, 'd', 'c', arg1)"
        },
        {
            "annotation": "if there is any letter replace that with d x",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _x _d))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_924_if_there_is_any_letter_replace_that_with_d_x(arg1):\n    return f0(f0_0, arg1, 'x', 'd')"
        },
        {
            "annotation": "if the word starts with any letter any letter replace that with m w",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) (cdr $0) _w _m)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_925_if_the_word_starts_with_any_letter_any_letter_replace_that_with_m_w(arg1):\n    cdr_1 = arg1[1:]\n    f5_1 = f5(f5_0, cdr_1, 'w', 'm')\n    return f6(f6_0, lambda lx: f5(f5_0, cdr_1, 'w', 'm'), arg1)"
        },
        {
            "annotation": "if the word starts with any letter add w before that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons _w $0)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_928_if_the_word_starts_with_any_letter_add_w_before_that(arg1):\n    cons_1 = ['w'] + arg1\n    return f6(f6_0, lambda lx: ['w'] + lx, arg1)"
        },
        {
            "annotation": "if the word ends with s add l after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (if (_rmatch (_rtail $0) _s) (_rappend _l $0) $0)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_931_if_the_word_ends_with_s_add_l_after_that(arg1):\n    rappend_1 = arg1 + ['l']\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 's')\n    if_1 = rappend_1 if rmatch_1 else arg1\n    return f6(f6_0, lambda lx: rappend_1 if rmatch_1 else lx, arg1)"
        },
        {
            "annotation": "if the word ends with consonant replace that with y k",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _k _y $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_933_if_the_word_ends_with_consonant_replace_that_with_y_k(arg1):\n    return f3(f3_0, 'k', 'y', arg1)"
        },
        {
            "annotation": "if there is s add m after that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _s _s _m))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_946_if_there_is_s_add_m_after_that(arg1):\n    return f4(f4_0, arg1, 's', 's', 'm')"
        },
        {
            "annotation": "if the word ends with consonant any letter replace that with c",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (if (_rmatch (_rtail (_rrevcdr $0)) _e) $0 (_rappend _c (_rrevcdr (_rrevcdr $0))))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_947_if_the_word_ends_with_consonant_any_letter_replace_that_with_c(arg1):\n    rrevcdr_1 = arg1[:-1]\n    rrevcdr_2 = rrevcdr_1[:-1]\n    rappend_1 = rrevcdr_2 + ['c']\n    rrevcdr_3 = arg1[:-1]\n    rtail_1 = rrevcdr_3[-1]\n    rmatch_1 = __ismatch(rtail_1, 'e')\n    if_1 = arg1 if rmatch_1 else rappend_1\n    return f6(f6_0, lambda lx: lx if rmatch_1 else rappend_1, arg1)"
        },
        {
            "annotation": "if the word starts with consonant replace that with m j",
            "best_program": "(lambda (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _m (cdr (_rsplit _rempty $0)) $0 (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _e $0 $0 (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _j _m))) $0)))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f1(arg1, arg2, arg3, arg4):\n    rrevcdr_1 = arg1[:-1]\n    car_1 = rrevcdr_1[0]\n    rmatch_1 = __ismatch(car_1, arg2)\n    return arg1 if rmatch_1 else arg2\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_950_if_the_word_starts_with_consonant_replace_that_with_m_j(arg1):\n    f5_1 = f5(f5_0, arg1, 'j', 'm')\n    f1_1 = f1(f1_0, 'e', arg1, arg1, f5_1)\n    f6_1 = f6(f6_0, lambda lx: f1(f1_0, 'e', lx, lx, f5_1), arg1)\n    rsplit_1 = __regex_split('', arg1)\n    cdr_1 = rsplit_1[1:]\n    return f1(f1_1, 'm', cdr_1, arg1, f6_1)"
        },
        {
            "annotation": "if the word ends with any letter add e after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend _e $0)) $0))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_954_if_the_word_ends_with_any_letter_add_e_after_that(arg1):\n    rsplit_1 = __regex_split('a', arg1)\n    rappend_1 = rsplit_1 + ['e']\n    return \"\".join(rappend_1)",
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_954_if_the_word_ends_with_any_letter_add_e_after_that(arg1):\n    rappend_1 = arg1 + ['e']\n    return f6(f6_0, lambda lx: lx + ['e'], arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with f t",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _t _f)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_956_if_the_word_starts_with_any_letter_replace_that_with_f_t(arg1):\n    f5_1 = f5(f5_0, arg1, 't', 'f')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 't', 'f'), arg1)"
        },
        {
            "annotation": "if the word ends with any letter replace that with f i",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _i _f $0))",
            "best_valid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef re2_train_959_if_the_word_ends_with_any_letter_replace_that_with_f_i(arg1):\n    rsplit_1 = __regex_split('', arg1)\n    rrevcdr_1 = rsplit_1[:-1]\n    rappend_1 = rrevcdr_1 + ['f']\n    rappend_2 = rappend_1 + ['i']\n    return \"\".join(rappend_2)",
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_959_if_the_word_ends_with_any_letter_replace_that_with_f_i(arg1):\n    return f3(f3_0, 'i', 'f', arg1)"
        },
        {
            "annotation": "if the word starts with any letter replace that with v k",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _k _v)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_960_if_the_word_starts_with_any_letter_replace_that_with_v_k(arg1):\n    f5_1 = f5(f5_0, arg1, 'k', 'v')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'k', 'v'), arg1)"
        },
        {
            "annotation": "if the word starts with any letter double that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (cons (car $0) $0)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_968_if_the_word_starts_with_any_letter_double_that(arg1):\n    car_1 = arg1[0]\n    cons_1 = [car_1] + arg1\n    return f6(f6_0, lambda lx: [car_1] + lx, arg1)"
        },
        {
            "annotation": "if there is any letter replace that with y o",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $2 (lambda (_rconcat $1 $2)))))) $0 _o _y))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f0(arg1, arg2, arg3):\n    rconcat_1 = arg2 + arg3\n    return f8(f8_0, arg3, lambda lx: lx + lx)\n\ndef re2_train_969_if_there_is_any_letter_replace_that_with_y_o(arg1):\n    return f0(f0_0, arg1, 'o', 'y')"
        },
        {
            "annotation": "if there is g replace that with b",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _g $0 _b))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_974_if_there_is_g_replace_that_with_b(arg1):\n    return f7(f7_0, 'g', arg1, 'b')"
        },
        {
            "annotation": "if there is c replace that with b",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _c $0 _b))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_977_if_there_is_c_replace_that_with_b(arg1):\n    return f7(f7_0, 'c', arg1, 'b')"
        },
        {
            "annotation": "if there is o replace that with k",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _o $0 _k))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_979_if_there_is_o_replace_that_with_k(arg1):\n    return f7(f7_0, 'o', arg1, 'k')"
        },
        {
            "annotation": "if the word starts with consonant any letter replace that with r",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (if (_rmatch (car (_rrevcdr $0)) $1)))) _i $0 $0 (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) (cdr $0) _rempty _r))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f1(arg1, arg2, arg3, arg4):\n    rrevcdr_1 = arg1[:-1]\n    car_1 = rrevcdr_1[0]\n    rmatch_1 = __ismatch(car_1, arg2)\n    return arg1 if rmatch_1 else arg2\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_985_if_the_word_starts_with_consonant_any_letter_replace_that_with_r(arg1):\n    cdr_1 = arg1[1:]\n    f5_1 = f5(f5_0, cdr_1, '', 'r')\n    f1_1 = f1(f1_0, 'i', arg1, arg1, f5_1)\n    return f6(f6_0, lambda lx: f1(f1_0, 'i', lx, lx, f5_1), arg1)"
        },
        {
            "annotation": "if the word ends with any letter replace that with t",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend _t (_rrevcdr $0))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "import re\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_987_if_the_word_ends_with_any_letter_replace_that_with_t(arg1):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + ['t']\n    return f6(f6_0, lambda lx: rrevcdr_1 + ['t'], arg1)"
        },
        {
            "annotation": "if the word ends with any letter replace that with x q",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _q _x $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_988_if_the_word_ends_with_any_letter_replace_that_with_x_q(arg1):\n    return f3(f3_0, 'q', 'x', arg1)"
        },
        {
            "annotation": "if there is n replace that with f",
            "best_program": "(lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) _n $0 _f))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_989_if_there_is_n_replace_that_with_f(arg1):\n    return f7(f7_0, 'n', arg1, 'f')"
        },
        {
            "annotation": "if the word starts with any letter replace that with b f",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _f _b)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_992_if_the_word_starts_with_any_letter_replace_that_with_b_f(arg1):\n    f5_1 = f5(f5_0, arg1, 'f', 'b')\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'f', 'b'), arg1)"
        },
        {
            "annotation": "if there is c add n before that",
            "best_program": "(lambda (#(lambda (lambda (lambda (lambda (#(lambda (lambda (lambda (#(lambda (lambda (_rflatten (map $0 (_rsplit _rdot $1))))) $1 (lambda (if (_rmatch $3 $0) $1 $0)))))) $2 $3 (_rconcat $1 $0)))))) $0 _c _n _c))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f4(arg1, arg2, arg3, arg4):\n    rconcat_1 = arg2 + arg1\n    return f7(f7_0, arg3, arg4, rconcat_1)\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f8(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg2)\n    map_1 = list(map(arg1, rsplit_1))\n    return \"\".join(map_1)\n\ndef f7(arg1, arg2, arg3):\n    rmatch_1 = __ismatch(arg4, arg1)\n    if_1 = arg2 if rmatch_1 else arg1\n    return f8(f8_0, arg2, lambda lx: lx if rmatch_1 else lx)\n\ndef re2_train_993_if_there_is_c_add_n_before_that(arg1):\n    return f4(f4_0, arg1, 'c', 'n', 'c')"
        },
        {
            "annotation": "if the word ends with consonant replace that with a",
            "best_program": "(lambda (#(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend (if (_rmatch (_rtail $0) _e) _e $1) (_rrevcdr $0))))) _a $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef __ismatch(s1, s2):\n    try:\n        return re.fullmatch(re.compile(s1), s2) is not None \n    except:\n        return False\n\ndef f2(arg1, arg2):\n    rrevcdr_1 = arg1[:-1]\n    rtail_1 = arg1[-1]\n    rmatch_1 = __ismatch(rtail_1, 'e')\n    if_1 = 'e' if rmatch_1 else arg2\n    rappend_1 = rrevcdr_1 + [if_1]\n    return f6(f6_0, lambda lx: rrevcdr_1 + [if_1])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_996_if_the_word_ends_with_consonant_replace_that_with_a(arg1):\n    return f2(f2_0, 'a', arg1)"
        },
        {
            "annotation": "if the word starts with any letter add n after that",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) $0 _n (car $0))) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_997_if_the_word_starts_with_any_letter_add_n_after_that(arg1):\n    car_1 = arg1[0]\n    f5_1 = f5(f5_0, arg1, 'n', car_1)\n    return f6(f6_0, lambda lx: f5(f5_0, lx, 'n', car_1), arg1)"
        },
        {
            "annotation": "if the word starts with any letter any letter replace that with t n",
            "best_program": "(lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (#(lambda (lambda (lambda (cons $0 (cons $1 (cdr $2)))))) (cdr $0) _n _t)) $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f5(arg1, arg2, arg3):\n    cdr_1 = arg3[1:]\n    cons_1 = [arg2] + cdr_1\n    return [arg1] + cons_1\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_998_if_the_word_starts_with_any_letter_any_letter_replace_that_with_t_n(arg1):\n    cdr_1 = arg1[1:]\n    f5_1 = f5(f5_0, cdr_1, 'n', 't')\n    return f6(f6_0, lambda lx: f5(f5_0, cdr_1, 'n', 't'), arg1)"
        },
        {
            "annotation": "if the word ends with any letter replace that with i c",
            "best_program": "(lambda (#(lambda (lambda (#(lambda (lambda (_rflatten ($1 (_rsplit _rdot $0))))) (lambda (_rappend $2 (_rappend $1 (_rrevcdr $0))))))) _c _i $0))",
            "best_valid_translation": null,
            "best_invalid_translation": "\n\ndef __regex_split(s1, s2):\n    # Splits s2 on regex s1 as delimiter, including the matches\n    try:\n        # Special case -- we override splitting on \"\" to be splitting on \".\"\n        # to match OCaml.\n        if len(s1) == 0: s1 = \".\"\n        ret = []\n        remaining = s2\n        m = re.search(re.compile(s1), remaining)\n        while m is not None:\n            prefix = remaining[0:m.start()]\n            if len(prefix) > 0:\n                ret.append(prefix)\n            ret.append(remaining[m.start():m.end()])\n            remaining = remaining[m.end():]\n            m = re.search(re.compile(s1), remaining)\n        if len(remaining) > 0:\n            ret.append(remaining)\n        return ret        \n    except:\n        return [s2]\n\ndef f3(arg1, arg2, arg3):\n    rrevcdr_1 = arg1[:-1]\n    rappend_1 = rrevcdr_1 + [arg2]\n    rappend_2 = rappend_1 + [arg3]\n    return f6(f6_0, lambda lx: rappend_1 + [lx])\n\ndef f6(arg1, arg2):\n    rsplit_1 = __regex_split('.', arg1)\n    return \"\".join(['arg2', 'rsplit_1'])\n\ndef re2_train_999_if_the_word_ends_with_any_letter_replace_that_with_i_c(arg1):\n    return f3(f3_0, 'c', 'i', arg1)"
        }
    ]
}